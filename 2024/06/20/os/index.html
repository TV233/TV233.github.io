<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Tviak的普通观测站" href="https://blog.tviakowo.live/rss.xml"><link rel="alternate" type="application/atom+xml" title="Tviak的普通观测站" href="https://blog.tviakowo.live/atom.xml"><link rel="alternate" type="application/json" title="Tviak的普通观测站" href="https://blog.tviakowo.live/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="学习"><link rel="canonical" href="https://blog.tviakowo.live/2024/06/20/os/"><title>操作系统复习 | Tviak's Observatory = Tviak的普通观测站 = 跨出自己的舒适区很难，但跨出去了就是成长。</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">操作系统复习</h1><div class="meta"><span class="item" title="创建时间：2024-06-20 13:40:04"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-06-20T13:40:04+08:00">2024-06-20</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>22k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>29 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Tviak's Observatory</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/TV233/blogpic@master/img/90488413_p0.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/TV233/blogpic@master/img/84462180_p0.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/TV233/blogpic@master/img/88401634_p30.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/TV233/blogpic@master/img/101460781_p0.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/TV233/blogpic@master/img/92957760_p0.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/TV233/blogpic@master/img/84179374_p0.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.tviakowo.live/2024/06/20/os/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Tviak"><meta itemprop="description" content="跨出自己的舒适区很难，但跨出去了就是成长。, 观测世界和自己的一般通过观测者"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Tviak的普通观测站"></span><div class="body md" itemprop="articleBody"><p>修改自<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NwaWN5X2NoaWNrZW4xMjMvYXJ0aWNsZS9kZXRhaWxzLzEzMTQzMTcxOQ=="> https://blog.csdn.net/spicy_chicken123/article/details/131431719</span></p><p>感谢明月出天山大佬和编写飞书文档的各位大佬！！</p><p>此文章主要针对于考试的简答题，想看计算题可以移步到这篇文章：<br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3BpY3lfY2hpY2tlbjEyMy9hcnRpY2xlL2RldGFpbHMvMTMxNDMxNzgy">blog.csdn.net/spicy_chicken123/article/details/131431782</span></p><h2 id="操作系统引论"><a class="markdownIt-Anchor" href="#操作系统引论">#</a> 操作系统引论</h2><ol><li><p>OS 的定义、目标、作用</p><blockquote><ol><li>OS 定义：操作系统是位于硬件层 (<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1IQUwmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">HAL</span>) 之上，所有其它系统软件层之下的一个系统软件，使得管理系统中的各种软件和硬件资源得以充分利用，方便用户使用计算机系统。**</li><li>OS 目标：方便性，有效性，可扩展性，开放性 **</li><li>OS 作用：作为用户与<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTglQUUlQTElRTclQUUlOTclRTYlOUMlQkElRTclQTElQUMlRTQlQkIlQjYmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">计算机硬件</span>系统之间的接口，作为资源管理者，作为扩展机器</li></ol></blockquote></li><li><p>三种基本操作系统的基本原理和异同（批处理操作系统，分时操作系统，实时操作系统）</p><blockquote><ol><li>单道批处理操作系统：<ul><li>自动性、顺序性、单道性</li><li>系统对作业的处理都是成批进行的，且在内存中始终仅存一道作业运行，运行结束或出错，才自动调另一道作业运行。</li><li>优点：减少人工操作，解决了作业的自动接续</li><li>缺点：平均周转时间长，没有交互能力</li></ul></li><li>多道批处理操作系统<ul><li>多道性、无序性、调度性（进程调度和作业调度）</li><li>在内存中存放多道作业运行，运行结束或出错，自动调度内存中的另一道作业运行。</li><li>多道批处理的主要优点：提高了资源利用率和吞吐能力。</li><li>多道批处理的主要缺点：平均周转时间长，没有交互能力。</li></ul></li><li>分时操作系统 (time-sharing system)<ul><li>多路性：一个主机与多个终端相连；</li><li>独立性：彼此独立操作，互不干扰；</li><li>及时性：系统能在很短的时间得到回答；</li><li>交互性：能实现人机对话（区别于批处理系统）；</li></ul></li><li>实时操作系统 (real time system)<ul><li>多路性：能对多个对象进行控制。</li><li>独立性：独立运行，不混淆，不破坏。</li><li>交互性：仅限于访问系统中某些特定的专用服务程序。</li><li>可靠性：高可靠性，应具有多级容错防护能力。</li><li>及时性：不同的系统要求不一样，控制对象必须在<br>截止时间内完成。</li></ul></li></ol></blockquote></li><li><p><em>OS 的特征</em>（期中考）</p><blockquote><p><strong>现代 OS 的四个基本特征</strong>：并发性（最重要的特征），共享性，虚拟性，异步性，并发是最重要的特征，其它特征都以并发为前提</p><ul><li>并发性：两个或多个事件在同一时间间隔内发生</li><li>共享性：系统中的资源可供内存中多个并发执行的进程同时使用（分为互斥共享和同时访问）</li><li>虚拟性：通过某种技术把一个物理实体变为若干个逻辑上的对应物的功能（时分复用技术【虚拟处理机和虚拟设备】，空分复用技术）</li><li>异步性：进程是以人们不可预知的速度向前推进的</li></ul></blockquote></li><li><p>OS 的功能 **</p><blockquote><ol><li>处理机管理：进程控制，进程同步和互斥，进程通信，进程调度</li><li>存储器管理：内存分配，内存保护，地址映射，内存扩充</li><li>设备管理：缓冲管理，设备分配，设备处理</li><li>文件管理：文件存储空间管理，目录管理，文件的读 / 写管理和保护</li><li>向用户提供 “操作系统与用户的接口”</li></ol></blockquote></li></ol><h2 id="处理机管理"><a class="markdownIt-Anchor" href="#处理机管理">#</a> 处理机管理</h2><ol><li><p>进程和线程的概念</p><blockquote><p>在引入线程的操作系统中，线程是系统独立调度和分配的基本单位 ，进程是拥有资源和独立运行的基本单位</p><p>在未引入线程的操作系统中，进程是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的基本单位</p></blockquote></li><li><p><em>进程的基本状态及状态转换的原因</em></p><blockquote><ol><li><p>进程五种状态</p><ul><li>就绪：准备执行</li><li>执行：占用处理机（单处理机环境中，某一时刻仅一个进程占用处理机）</li><li>阻塞：等待某事件发生才能执行，如等待 I/O 完成等</li><li>新建：进程已经创建，但未被 OS 接纳为可执行进程，并且程序还在辅存，PCB 在内存</li><li>终止：因停止或取消，被 OS 从执行状态释放</li></ul></li><li><p>进程转换模型<img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/513696799b6470a47cea827b2883161a.png" alt="image.png"></p><p>① 空 → 新状态：新创建的进程首先处于新状态。</p><p>② 新状态 → 就绪状态：当系统允许增加就绪进程时，操作系统接纳新建状态进程，将它变为就绪状态，插入就绪队列中。</p><p>③ <strong>就绪状态 → 执行状态</strong>：当处理机空闲时，将从就绪队列中选择一个进程执行，该选择过程称为<strong>进程调度</strong>，或将<strong>处理机分派给一个进程，该进程状态从就绪转变为执行</strong>。</p><p>④ 执行状态 → 终止状态：执行状态的进程<strong>执行完毕</strong>，或出现诸如访问地址越界、非法指令等错误，而被异常结束，则进程从执行状态转换为终止状态。</p><p>⑤ <strong>执行状态 → 就绪状态</strong>：分时系统中，<strong>时间片用完</strong>，或优先级高的进程到来，将中断较低优先级进程的执行。进程从执行状态转变为就绪状态，等待下一次调度。</p><p>⑥ ** 执行状态 → 阻塞状态：** 执行进程需要等待某事件发生。通常，会因为进程需要的系统调用不能立即完成，如读文件、共享虚拟内存、等待 I/O 操作、等待另一进程与之通信等事件而阻塞。</p><p>⑦ <strong>阻塞状态 → 就绪状态</strong>：当阻塞进程等待的事件发生，就转换为就绪状态。进入就绪队列排队，等待被调度执行。</p></li></ol></blockquote></li><li><p>PCB 的概念、作用、包含信息、组织方式</p><blockquote><ol><li><p>为使程序（含数据）能<strong>独立运行</strong>，应为之配置一进程控制块，即 PCB (Process Control Block)</p></li><li><p>而<strong>由程序段、相关的数据段和 PCB 三部分便构成了进程实体</strong>。</p></li><li><p>进程控制块的作用：</p><p>1） 作为独立运行基本单位的标志；<br>2） 能实现间断性运行方式；<br>3） 提供进程管理所需要的信息；<br>4） 提供进程调度所需要的信息；<br>5） 实现与其他进程的同步与通信。</p></li><li><p>进程控制块中的信息：进程标识符，处理机状态，进程调度信息，进程控制信息</p></li><li><p>PCB 的组织方式：线性方式，链接方式，索引方式</p></li></ol></blockquote></li><li><p>进程控制的原语操作</p><blockquote><p>常见的进程控制原语：进程创建原语，进程终止原语，进程阻塞原语，进程唤醒原语，进程挂起原语，进程激活原语，wait，signal</p></blockquote></li><li><p>进程互斥、临界区、进程同步的基本概念、同步准则</p><blockquote><ol><li><strong>进程同步的主要任务</strong>：是使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。</li><li><strong>进程同步</strong>是进程之间的直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而等待、传递信息所产生的制约关系</li><li><strong>进程互斥</strong>是进程之间的<strong>间接制约关系</strong>，当一个进程进入<strong>临界区使用临界资源</strong>时，另一个进程必须<strong>等待</strong>，当占用临界资源的进程<strong>退出</strong>临界区后，这个进程才会解除阻塞状态。**</li><li>临界资源：一段时间内只允许一个进程访问的资源 **</li><li><strong>临界区</strong>：在每个进程中访问临界资源的<strong>那段程序</strong></li><li>同步准则<ul><li>空闲让进：如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入</li><li>忙则等待：任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待</li><li>有限等待：进入临界区的进程要在有限的时间内退出，以便其它进程能及时进入自己的临界区</li><li>让权等待：如果进程不能进入自己的临界区，则应该让出 CPU，避免进程出现 “忙等” 的现象</li></ul></li></ol></blockquote></li><li><p>四种信号量机制：整型信号量，记录型信号量，AND 型信号量，信号量集</p><p>记录型信号量：</p><blockquote><p>在信号量机制中，除了需要一个用于代表资源数目的整型变量 value 外，还应增加一个进程链表指针 L，用于链接上述的所有等待进程。</p><p>记录型信号量是由于它采用了记录型的数据结构而得名的。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">process_control_block</span> <span class="token operator">*</span>list<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span> semaphore<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 等待操作</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>S<span class="token operator">-></span>value <span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-></span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token comment">// 将当前进程加入等待队列</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token operator">-></span>L<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// 信号操作</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>S<span class="token operator">-></span>value <span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-></span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token comment">// 唤醒等待队列中的进程</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token operator">-></span>L<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></blockquote></li><li><p>信号量的应用</p><blockquote><p>用信号量实现进程互斥</p><p>利用信号量实现前趋关系</p></blockquote></li><li><p>经典进程同步问题：生产者与消费者问题，哲学家进餐问题，读者 - 写者问题 ***</p><blockquote><p>考察伪代码</p><p>生产者与消费者问题：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression">n</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>item buffer<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 缓冲区数组</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> in <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 生产者向缓冲区中添加数据的位置</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> out <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 消费者从缓冲区中取出数据的位置</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 生产者进程</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token function">produce_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生产一个数据项</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token comment">// 等待缓冲区中有空的位置</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token comment">// 获取对缓冲区的访问权</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token comment">// 将数据项添加到缓冲区</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  buffer<span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  in <span class="token operator">=</span> <span class="token punctuation">(</span>in <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> BUFFER_SIZE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token comment">// 释放对缓冲区的访问权</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token comment">// 增加 full 计数</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token function">V</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token comment">// 消费者进程</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token comment">// 等待缓冲区中有数据</span></pre></td></tr><tr><td data-num="29"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>  <span class="token comment">// 获取对缓冲区的访问权</span></pre></td></tr><tr><td data-num="31"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>  <span class="token comment">// 从缓冲区中取出一个数据项</span></pre></td></tr><tr><td data-num="33"></td><td><pre>  item <span class="token operator">=</span> buffer<span class="token punctuation">[</span>out<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>  out <span class="token operator">=</span> <span class="token punctuation">(</span>out <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> BUFFER_SIZE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  <span class="token comment">// 释放对缓冲区的访问权</span></pre></td></tr><tr><td data-num="36"></td><td><pre>  <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>  <span class="token comment">// 增加 empty 计数</span></pre></td></tr><tr><td data-num="38"></td><td><pre>  <span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>  <span class="token function">consume_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 消费数据项</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></blockquote></li><li><p>进程间通信的原理和实现方法</p><blockquote><p>4 种：共享存储器系统，管道通信系统，消息传递系统，客户机 - 服务器系统 **</p><p>消息传递系统分为直接消息传递系统和信箱通信</p><p>系统为<strong>信箱通信</strong>提供了若干条原语，分别用于信箱的创建、撤消和消息的发送、接收等。</p><p>优点：在读 / 写时间上的随机性</p><p>写进程 -&gt; 信箱（中间实体）-&gt; 读进程原语</p><p>消息的发送和接收</p><p>Send (mailbox, message)</p><p>Receive (mailbox, message)</p><p>信箱分为以下三类：</p><p>（1）私用信箱</p><p>（2）公用信箱</p><p>（3）共享信箱</p><p>在利用信箱通信时，在发送进程和接收进程之间，存在以下四种关系：</p><p>（1）一对一关系。</p><p>（2）多对一关系，客户 / 服务器交互。</p><p>（3）一对多关系， 广播方式。</p><p>（4）多对多关系。</p></blockquote></li><li><p><em>处理机调度的基本概念和种类</em>（期中考）</p><blockquote><ol><li><p>高级调度</p><p>▪调度对象：作业</p><p>▪又称作业调度、长程调度、接纳调度</p><p>▪实现：作业管理程序</p><p>▪将外存作业调入内存，创建 PCB 等，插入就绪队列。</p><p>▪用于批处理系统，分 / 实时系统一般直接入内存，无此环节。</p><p>▪频度：最低，分钟级</p></li><li><p>低级调度</p><p>▪又称进程调度或短程调度</p><p>▪对象：就绪进程（或内核线程）</p><p>▪功能：决定就绪队列中的那个进程应获得处理机，并将处理机分配给选中的进程。</p><p>▪实现者 ：分派程序（dispatcher)</p><p>▪应用范围：都有</p><p>▪频度：最频繁，毫秒级</p></li><li><p>中级调度</p><p>▪又称内存调度、中程调度</p><p>▪对象：挂起的进程</p><p>▪功能：把外存上那些已经具备运行条件的就绪进程重新载入内存。从静止就绪到活动就绪。</p><p>▪实现：内存管理中的对换进程</p><p>▪应用范围：具有对换功能的操作系统</p><p>▪频度：中等</p></li></ol></blockquote></li><li><p>选择调度算法的准则，周转时间，带权周转时间，响应时间</p><blockquote><ol><li>周转时间：接纳等待时间、执行等待时间、执行时间、I/O 时间。</li><li>带权周转时间：作业的周转时间 T 与系统为它提供服务的时间 Ts 之比。 W = T/Ts</li><li>响应时间：等待时间与要求服务时间之和</li></ol></blockquote></li><li><blockquote><p><strong>算法：（抢占 / 非抢占、调度时机）</strong></p><ul><li><p><strong>先来先服务 FCFS</strong></p><p>既可用于 <strong>作业调度</strong> ，也可用于 <strong>进程调度</strong></p><p>作业调度时，优先选择后备作业中最先进入队列的作业</p><p>进程调度时，每次调度从就绪队列中选择一个最先进入该队列的进程。</p><p>有利于长作业（长进程 ），而不利于短作业（短进程 ）</p><p>缺陷：对待短作业（进程）不公平，如果他们排在队列后面，则其等待时间远大于其执行时间。</p></li><li><p><strong>短作业 (进程) 优先 SJF/SPF</strong></p><p><strong>短作业 / 进程优先调度算法 SJ§F</strong> 是指对短作业或短进程优先调度的算法 。 它们可以分别用于作业调度和进程调度 。</p><p><strong>短作业</strong>优先的调度算法 是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行 。</p><p><strong>短进程</strong>优先调度算法 则是从就绪队列中选出一估计运行时间最短的进程，处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度 。</p><p>缺点：</p><ul><li>该算法对长作业不利，如作业 C 的周转时间由 10 增至 16 其带权周转时间由 2 增至 3.1 。甚至长作业长期得不到执行</li><li>不能保证紧迫性作业 进程 会被及时处理。</li><li>由于作业 进程 的长短只是根据用户所提供的估计执行时间而定的，而用户不一定对执行时间估计那么准确，致使该算法不一定能真正做到短作业优先调度。</li></ul></li><li><p><strong>时间片轮转 RR</strong></p><ul><li><p>系统将所有的就绪进程按先来先服务的原则，排成一个队列，每次调度时把 CPU 分配给队首进程。并令其执行一个时间片</p></li><li><p>当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的未尾：然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片</p></li><li><p>这样就可以保证就绪队列中的所有进程，在一给定的时间内，均能获得一时间片的处理机执行时间。即系统能在给定的时间内，响应所有用户的请求</p></li><li><p>时间片的设置</p><ul><li><p><strong>进程切换将会增加系统的额外开销。</strong></p><p><strong>时间片设定得太短，进程切换会非常频繁，从而降低处理机的效率；时间片设定得太长，将无法满足交互式用户对响应时间的要求。</strong></p><p><strong>因此，时间片大小的确定应综合考虑系统的最大用户数、响应时间、系统效率等多种因素。</strong></p></li></ul></li></ul></li><li><p><strong>基于优先权 PSA</strong></p><ul><li>外部赋予作业（进程）相应的优先级，例如以作业的紧迫程度作为优先级。</li><li>选择优先级高 的作业（进程）投入 运行。</li><li>即可用于作业调度算法，也可用于进程调度。</li></ul></li><li><p><strong>高响应比优先 HRRN</strong></p><ul><li><p>既考虑作业的等待时间，又考虑作业的运行时间</p></li><li><p>赋予作业动态优先级，优先级随作业等待时间延长而增加，从而使长作业的优先级在等待期间不断增加</p></li><li><p>优先权 = （等待时间 + 要求服务时间）/ 要求服务时间</p></li></ul><p>等待时间 + 要求服务时间 = 响应时间</p><p>故优先级相当于响应比 R_p</p><ul><li><p>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。</p></li><li><p>当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。</p></li><li><p>对于长作业，作业的优先级可以随等待时间的增加而提高，从而也可获得处理机。</p></li></ul><p>简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序 ，避免长作业长期得不到服务。</p></li><li><p><strong>多级反馈队列 MLFQ</strong>/FB</p><ul><li>多级反馈队列调度算法设置多个就绪队列，并为每个队列赋予不同的优先级。</li><li>第一个队列的优先级最高，其余队列的优先级逐个降低。不同队列中的进程所赋予的执行时间片的大小也各不相同，在优先级愈高的队列中其时间片就愈小。</li><li>接着每个队列都采用 FCFS 算法，当新进程进入内存后先将它放入第一等待队列的末尾进行调度。如果该进程能在该时间片内完成便可撤离，否则调度程序将其转入第二队列的末尾等待调度。当进程最后被降到第 n 队列后，在第 n 队列中按 RR 调度算法运行。</li><li>如果 A 的优先级 &gt; B 的优先级，运行 A；</li><li>如果 A 的优先级 = B 的优先级，轮转运行 A 和 B；</li><li>工作进入系统时，放在最上层队列。</li><li>一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次），就移入低一级队列；</li><li>经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</li></ul></li><li><p>实时调度（了解）</p><ul><li><p>基本条件</p><ul><li><p>提供必要的信息</p></li><li><p>系统处理能力强</p></li><li><p>采用抢占式调度机制</p></li><li><p>具有快速切换机制</p></li></ul></li><li><p>实时调度算法</p><ul><li><p>非抢占式调度算法</p><p>​ 调度程序每次选择队列中的第一个任务投入运行。该任务完成后，便把它挂在轮转队列的末尾，等待下次调度运行，而调度程序再 选择下一个 (队首) 任务运行。</p><p>非抢占优先权调度算法</p><p>​	如果在实时系统中存在着要求较为严格 (响应时间为数百毫秒) 的任务，则可采用非抢占式优先调度算法为这些任务赋予较高的优先级。	当这些实时任务到达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后才能被调度执行。</p><p>抢占式调度算法</p><p>基于时钟中断的抢占式优先权调度算法</p><p>立即抢占的优先权调度算法</p><p>最早截止时间优先级 EDF（Earliest Deadline First）算法</p><p>优先级确定：根据任务的开始截止时间来确定任务的优先级。截止时间愈早，其优先级愈高。</p><p>实时任务就绪队列：按各任务截止时间的早晚排序；具有最早截止时间的任务排在队列的最前面。</p><p>调度顺序：总是选择就绪队列中的第一个任务，为之分配处理机，使之投入运行。</p><p>适用范围：既可用于抢占式调度，也可用于非抢占式调度方式中。</p></li><li><p>最低松弛度优先即 LLF (Least Laxity First) 算法</p><p>松弛度 = 完成截止时间–剩余运行时间–当前时间</p><p>该算法按松弛度排序实时任务的就绪队列，松弛度值最小的任务排在队列最前面，调度程序总是选择就绪队列中的队首任务执行。</p><p>该算法主要用于可抢占调度方式中。</p></li></ul></li></ul></li></ul></blockquote></li><li><p>常见的两种实时调度算法</p><blockquote><p>最早截止时间优先算法 (EDF)，最低松弛度优先算法（LLF）</p></blockquote></li><li><p><em>死锁概念，处理死锁的基本方法</em>、死锁产生的原因，四个必要条件</p><blockquote><ol><li><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p></li><li><p>产生死锁的原因可归结为如下两点：<br>（1）竞争资源：<strong>可重用资源的竞争，可消耗资源的竞争，不可抢占资源的竞争</strong><br>（2）进程间推进顺序非法</p></li><li><p>四个必要条件：</p><p>（1）互斥条件<br>（2）请求和保持条件<br>（3）不剥夺条件<br>（4）环路等待条件</p></li></ol></blockquote></li><li><p>死锁的预防</p><blockquote><ol><li>破坏请求与保持：系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源。从而进程在整个运行期间，便不会再提出资源要求，从而摒弃了请求和保持条件，由此可以避免发生死锁。<br>▪优点：简单、易于实现且很安全。<br>▪缺点：资源被严重浪费，使进程延迟运行。</li><li>破坏不剥夺：当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源。待以后需要时再重新申请。从而摒弃了 “不剥夺” 条件。<br>▪缺点：实现起来比较复杂且要付出很大代价</li><li>破坏环路等待：系统将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出</li></ol></blockquote></li><li><p>死锁的检测与解除</p><blockquote><p>死锁的检测 —— 资源分配图，死锁定理</p><ol><li>死锁定理：如果资源分配图中不存在环路，则系统中不存在死锁；反之，如果资源分配图中存在环路，则系统中可能存在死锁，也可能不存在死锁。</li><li>若能消去资源分配图中所有结点的连接边，使全部结点都成为孤立结点，则称该图是可完全简化图；若不能使该图完全简化，则称该图是不可完全化简图。可以证明：当且仅当系统某状态 S 所对应的资源分配图是不可完全化简的，则 S 是死锁状态。该充分条件称为死锁定理</li></ol><p>死锁的解除 —— 当发现有进程死锁时，常采用的两种方法是解除死锁：<br>（1）剥夺资源。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。<br>（2）撤消进程。最简单的撤消进程的方法，是使全部死锁进程都夭折掉；或者按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为止。</p></blockquote></li></ol><h2 id="存储器管理"><a class="markdownIt-Anchor" href="#存储器管理">#</a> 存储器管理</h2><ol><li><p>存储器管理的基本任务</p><blockquote><ol><li><p><strong>主存储器的分配和管理</strong></p><p>：按用户要求把适当的存储空间分配给相应的作业。一个有效的存储分配机制，应在用户请求时能作出快速的响应，分配相应的存储空间；在用户不再使用它时，应立即回收，以供其他用户使用。为此，这个存储分配机制应具有如下功能：</p><ul><li>记住每个存储区域的状态：哪些是已分配的，哪些是可以用作分配的。</li><li>实施分配：在系统程序或用户提出申请时，按所需的量给予分配；修改相应的分配记录表。</li><li>接受系统或用户释放的存储区域：并相应地修改分配记录表。</li></ul></li><li><p><strong>提高主存储器的利用率</strong>：使多道程序能动态地共享主存，最好能共享主存中的信息。</p></li><li><p><strong>“扩充” 主存容量</strong>：这是借助于提供虚拟存储器或其它自动覆盖技术来达到的。即为用户提供比主存的存储空间还大的地址空间。</p></li><li><p><strong>存储保护</strong>：确保各道用户作业都在所分配的存储区内操作，互不干扰。即要防止一道作业由于发生错误而损害其它作业，特别需要防止破坏其中的系统程序。这个问题不能用特权指令来加以解决，而必须由硬件提供保护功能，并由软件配合实现。</p></li></ol></blockquote></li><li><p>重定位的基本概念，为什么引入，动态重定位的概念、实现方式，什么情况下需要重定位</p><blockquote><p>装入内存时，相对地址（数据、指令地址）要作出相应的修改以得到正确的物理地址，这个修改的过程称为<strong>重定位。</strong></p><p>源程序经过编译产生的目标模块一般总是从 0 开始编址的，其中的地址都是相对于起始地址的<strong>相对地址</strong>。在将目标模块经过链接<strong>装入内存时</strong>，其分配到的<strong>内存空间的起始地址通常不为 0</strong>，因此指令和数据的实际物理地址和装入模块内的相对地址是不同的，<strong>为了使程序能够正确执行，必须将相对地址转换成物理地址，即进行重定位</strong>。</p><p>静态重定位：地址变换是在装入内存时一次完成的，且以后不能移动。</p><p>动态重定位：装入程序将装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时进行。在<strong>硬件地址变换机构</strong>的支持下，随着对每条指令或数据的访问<strong>自动进行地址变换</strong>，故称为动态重定位。</p><p>在内存分配过程中，不免出现许多不可利用的小的空闲空间以至于造成了内存的利用率不高。如果让已经存在的程序紧凑起来，那么，那些不可利用的小的空闲空间也就连成了更大的空闲空间以供利用，移动已经在内存中的程序就是动态重定位。</p><p>实现方式：要在不影响指令执行速度的同时实现地址变换，必须有硬件地址变换机构的支持，即须在系统中增设一个重定位寄存器，用它来存放程序在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。</p></blockquote></li><li><p>比较连续分配和离散分配，连续分配的三种方式</p><blockquote><p>（1）连续分配是指为一个用户程序分配一个连续的地址空间，包括<strong>单一连续分配方式</strong>，<strong>分区式分配方式</strong>（固定分区和动态分区），<strong>动态重定位分区</strong>（引入了紧凑）三种分配方式。单一方式将内存分为系统区和用户区，最简单，只用于单用户单任务操作系统；分区方式分固定和动态分区。<br>（2）离散分配方式分为分页、分段和段页式存储管理。分页式存储管理旨在提高内存利用率，分段式存储管理旨在满足用户（程序员）的需要，段页式存储管理则将两者结合起来，具有分段系统便于实现、可共享、易于保护和动态链接等优点，又能像分页系统很好解决外部碎片及为各段可离散分配内存等问题，是比较有效的存储管理方式。</p><p>连续分配方式不需要额外的硬件支持，且实现算法相对简单。但是在很多情况下会造成内存利用率低，系统吞吐量小和 CPU 利用率低等情况，虽然可以通过紧凑等方式有所调节，但是紧凑也会造成很大的系统开销。</p><p>离散分配方式需要额外的硬件支持，且实现的算法相对比较复杂，但是出于用户或操作系统的角度，离散分配方式在系统性能上或实现功能上明显比连续分配更灵活。比如信息的保护和共享等等方面，离散比连续更加容易实现。</p></blockquote></li><li><p>动态分区分配方式：分配、回收算法</p><blockquote><p>首次适应算法，最佳适应算法，最差适应算法，下次适应算法</p></blockquote></li><li><p>动态可重定位分区分配</p><blockquote><p>动态重定位：改变程序驻留位置后的地址重定位问题解决方法</p><p>紧凑：将内存中的所有作业进行移动，使它们全都相邻接，这样，可把原来分散的多个小分区合成一个大分区。这种技术称为存储器的 “紧凑”。（减少由于外零头造成的浪费）</p><p>在动态运行时转入的方式中，作业装入内存后的所有地址仍然都是相对逻辑地址。而将相对地址转换为绝对（物理）地址的工作被推迟到程序指令要真正执行时进行。为使地址的转换不会影响到指令的执行速度，必须<strong>有硬件地址变换机构</strong>的支持，程序在执行时，真正访问的内存地址是<strong>相对地址与重定位寄存器中的地址相加</strong>而形成的。<br>地址变换过程是在程序执行期间，随着对每条指令或数据的访问自动进行的，故称为动态重定位。<strong>当系统对内存进行了 “紧凑</strong>”，而使若干程序从内存的某处移至另一处时，不需对程序做任何修改，只要<strong>用该程序在内存的新起始地址去置换原来的起始地址</strong>即可。</p></blockquote></li><li><p>基本分页存储管理方式：为什么引入；地址变换机构和过程（含具有快表的情况）</p><blockquote><p>分页的优点：彻底消除了外零头，仅存在很少的内零头，提高了内存利用率。</p></blockquote></li><li><p>基本分段存储管理方式：为什么引入；地址变换机构和过程（含具有快表的情况）；信息的共享和保护</p><blockquote><p>分段引入原因：方便编程，信息共享，信息保护，动态增长，非常适合动态链接</p><p>分段易于实现<strong>段的共享和段的保护</strong>。</p></blockquote></li><li><p>虚拟存储器的基本概念：为什么要引入；特征；实现虚拟存储的关键技术</p><blockquote><ol><li>虚拟存储器：是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。</li><li>虚拟存储器的特征：<ul><li>多次性：是指一个作业被分成多次调入内存运行。</li><li>对换性：是指作业的运行过程中进行换进、换出。换进和换出能有效地提高内存利用率。</li><li>虚拟性：是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li></ul></li><li>虚拟存储器的实现方法：<ul><li>分页请求系统：在纯分页系统的基础上增加了请求调页、页面置换两大功能所形成的页式虚拟存储系统。<ul><li>为了实现请求调页、页面置换两大功能，系统必须提供如下的硬件支持：<strong>1. 请求分页的页表机制。2. 缺页中断机构。3. 地址变换机构。</strong></li><li>此外，实现请求调页、页面置换两大功能还需得到 OS 的支持。①实现请求调页的软件②实现页面置换的软件</li></ul></li><li>请求分段系统：它是在纯分段系统的基础上增加了请求调段、分段置换两大功能所形成的段式虚拟存储系统。<ul><li>为了实现请求调段、分段置换两大功能，系统必须提供如下的硬件支持：<strong>1. 请求分段的段表机制。2. 缺段中断机构。3. 地址变换机构。</strong></li><li>此外，实现请求调段、分段置换两大功能还需得到 OS 的支持。</li></ul></li></ul></li></ol></blockquote></li><li><p>请求分页系统的基本原理：页表机制；地址变换过程；页面置换算法</p><blockquote><ol><li><p>工作原理：作业运行时，只将当前的一部分装入内存其余的放在辅存，一旦发现访问的页不在主存中，则发出缺页中断，由 OS 将其从辅存调入主存，如果内存无空块，则根据某种算法选择一个页淘汰以便装入新的页面。</p></li><li><p>请求页表机构：</p><table><thead><tr><th>页号</th><th>页框号（物理块号）</th><th>状态位 P</th><th>访问字段 A</th><th>修改位 M</th><th>外存地址</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>状态位 (存在位) P：用于说明该页是否已调入内存，供程序访问时参考；D=0，该页不在内存。 D=1，该页在内存</li><li>访问位 A：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考。A=0，该页未被访问。A=1，该页被访问</li><li>修改位 M：用于表示该页在调入内存后是否被修改过，也是提供给置换算法在换出页面时是否将该页面写回外存作参考。M=0，该页在内存中未被修改。M=1，该页在内存中已经被修改</li><li>外存地址：用于指出该页在外存上的地址，供调入该页时使用。</li></ul></li><li><p>地址变换过程。<img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/ae4a2d2c5ded9f3cbdad926dff59d2fb.png" alt="image.png"></p></li><li><p>5 种页面置换算法</p></li></ol></blockquote></li><li><p>访问内存的有效时间</p><blockquote><ol><li>假设使用了快表，则 CPU 访问内存时有以下三种情况：设内存读写周期为 t，查找快表时间为 λ，缺页中断处理时间为ɛ</li><li>页面在内存且页表项在快表中：只需一次访问内存 ：EAT= λ + t</li><li>页面在内存但页表项不在快表中：需两次访问内存，一次读取页表，一次读取数据，另外还需更新快表：EAT= λ + t + t + λ=2 (λ + t)</li><li>页面不在内存：考虑查找快表时间、查找页表时间、缺页中断处理时间、更新快表时间、访问实际物理地址时间：EAT= λ + t +ɛ + λ + t = ɛ + 2 (λ + t)</li><li>引入快表命中率为 α，缺页中断率为 f，则有效访问内存时间为：EAT= λ + α t + (1- α)[t + f (t +ɛ +λ) + (1-f)(t +λ)]</li></ol></blockquote></li></ol><h2 id="设备管理"><a class="markdownIt-Anchor" href="#设备管理">#</a> 设备管理</h2><ol><li><p>I/O 控制方式：四种 I/O 方式的基本原理；四种 I/O 方式由低效到高效的演变</p><blockquote><ol><li><p>使用轮询的可编程 I/O 方式：程序 I/O（Programmed I/O）方式，或称为忙 —— 等待方式。</p><p>处理机向控制器发出一条 I/O 指令启动输入设备输入数据时，同时把 busy 置为 1，再不断<strong>循环测试</strong> busy。busy=0，完成输入，处理机读取数据，送入指定单元，完成一次 I/O。对状态寄存器中的忙 / 闲标志 busy 的检查实现控制。</p></li><li><p>使用中断的可编程 I/O 方式：当某进程要启动某个 I/O 设备工作时，便由 CPU 向相应的设备控制器<strong>发出一条 I/O 命令，然后立即返回继续执行原来的任务</strong>。设备控制器于是按照该命令的要求去控制指定 I/O 设备。此时，CPU 与 I/O 设备并行操作。</p></li><li><p>DMA 控制方式的特点：①数据传输的基本单位是数据块，即在 CPU 与 I/O 设备之间，每次传送至少一个数据块；②所传送的数据是<strong>从设备直接送入内存的，或者相反</strong>；③<strong>仅在传送一个或多个数据块的开始和结束时，才需 CPU 干预，整块数据的传送是在控制器的控制下完成的</strong>。</p></li><li><p>I/O 通道方式：I/O 通道方式是 DMA 方式的发展，它可进一步减少 CPU 的干预，即<strong>把对一个数据块的读 (或写) 为单位的干预，减少为对一组数据块的读 (或写) 及有关的控制和管理为单位的干预</strong>。 可实现 CPU、通道和 I/O 设备三者的并行操作，从而更有效地提高整个系统的资源利用率</p></li></ol></blockquote></li><li><p>缓冲管理：缓冲的概念，为什么引入缓冲</p><blockquote><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p><p>引入缓冲区的目的：为了缓和<strong> CPU 与 I/O 设备速度不匹配</strong>的矛盾；提高 CPU 和 I／O 设备的<strong>并行性</strong>； 减少对 CPU 的<strong>中断频率</strong>， 放宽对 CPU<strong> 中断响应时间</strong>的限制；解决<strong>数据粒度不匹配</strong>问题</p></blockquote></li><li><p>单缓冲如何提高 I/O 速度，它存在哪些不足，双缓冲、循环缓冲又如何提高 CPU 与 I/O 设备的并行性</p><blockquote><p>单缓冲：在设备和处理机之间设置一个缓冲。设备与处理机交换数据时，先把交换的数据写入缓冲区，然后需要数据的设备 / 处理机再从缓冲区中取走数据。</p><p>​	通过<strong>允许 CPU 和 I/O 设备异步操作</strong>，单缓冲<strong>减少了因速度不匹配导致的等待</strong>时间，提高了整体的<strong>吞吐量</strong>。</p><p>双缓冲：在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。此时操作系统可以从第一缓冲区中移出数据，并送入用户进程</p><p>环形缓冲区方式 （1）多个缓冲区。 每个缓冲区的大小相同。 （2）缓冲区可分成三种类型：① 空缓冲区 Empty，用 E 表示，用于存放输入数据；② 已装满数据的缓冲区 Full，用 F 表示，其中的数据提供给计算进程使用；③ 现行工作缓冲区 Current，用 C 表示，这是计算进程正在使用的缓冲区。</p></blockquote><pre><code>单缓冲
工作原理：
单缓冲技术涉及在CPU和I/O设备之间设立一个缓冲区。当I/O设备准备数据时，它会将数据写入缓冲区，随后CPU可以在不等待I/O操作完成的情况下继续执行其他任务。一旦数据准备好，CPU可以方便地从缓冲区读取数据，而I/O设备则可以开始下一次的数据传输，从而减少了直接CPU等待的时间。

提高I/O速度：
通过允许CPU和I/O设备异步操作，单缓冲减少了因速度不匹配导致的等待时间，提高了整体的吞吐量。

不足：

瓶颈问题：如果缓冲区的容量小或CPU处理数据的速度远快于数据填充缓冲区的速度，CPU仍需等待缓冲区填满或清空，这成为系统的瓶颈。
数据粒度不匹配：单缓冲可能无法有效应对数据传输速率的大幅波动，尤其是当I/O设备传输数据的速率与CPU处理速率差异很大时。
双缓冲
工作原理：
双缓冲使用两个缓冲区交替工作。当一个缓冲区正在被CPU处理时，另一个缓冲区可以由I/O设备填充数据。这样，CPU总能在一个缓冲区处理完后立即切换到另一个已填满的缓冲区，实现了连续的数据流处理。

提高并行性：
双缓冲显著提高了CPU与I/O设备的并行工作能力，因为CPU总有一个缓冲区可处理，同时I/O设备也在填充另一个缓冲区，减少了空闲等待时间。

不足：

额外资源消耗：相比单缓冲，双缓冲需要额外的内存空间。
特定情况下的效率问题：如果CPU处理速度极快，且I/O操作频繁但每次数据量不大，可能会出现短暂的等待，尽管这种情况相对较少。
循环缓冲（也称为环形缓冲）
工作原理：
循环缓冲是一个固定大小的缓冲区，被视为首尾相连的环。数据既可以顺序写入，也可以顺序读出，当达到缓冲区的末端时，会自动回到开头继续。这种设计使得缓冲区可以连续重复使用，适合连续的数据流处理。

提高并行性：
循环缓冲特别适用于连续的数据流处理，如音频或视频流，因为它可以连续不断地读写，无需等待缓冲区完全填满或清空，从而提高了数据处理的平滑性和并行性。

不足：

复杂性增加：管理和同步循环缓冲的读写指针比单缓冲或双缓冲更复杂。
潜在的溢出问题：如果没有适当的流量控制，生产者（写入方）过快或消费者（读取方）过慢可能导致数据溢出。
</code></pre></li><li><p>缓冲池是为了解决什么问题而引入，引入缓冲池后系统将如何处理 I/O 设备和 CPU 间的数据输送</p><blockquote><p>上述三种缓冲区的组织形式仅适用于某种特定的 I/O 进程和计算进程，属于专用缓冲。当系统中的设备很多时，将会有许多这样的循环缓冲区，消耗大量的内存空间，而且其利用率也不高。为了提高缓冲区的利用率，可以采用公共缓冲池技术，其中的缓冲区可为多个设备和进程服务。</p><p>缓冲池是为了解决以下几个关键问题而引入的：</p><ol><li><strong>CPU 与 I/O 设备速度不匹配</strong>：缓冲池通过在内存中预留一部分区域作为缓冲区集合，帮助协调 CPU 高速处理能力和 I/O 设备较慢的传输速率之间的差异。这样，即使 I/O 设备速度较慢，CPU 也可以继续执行其他任务，而不是等待数据传输完成。</li><li><strong>减少中断频率</strong>：没有缓冲池时，每次 I/O 操作完成或需要数据时都会触发中断，CPU 需要频繁响应这些中断，降低了效率。缓冲池可以累积一定量的数据后再通知 CPU，从而减少中断次数。</li><li><strong>提高并行性</strong>：通过允许 CPU 与多个 I/O 操作并行进行，缓冲池提升了系统的并发处理能力。例如，当一个缓冲区正在被 CPU 处理时，其他缓冲区可以用于新的 I/O 操作，保持数据流动。</li><li><strong>资源复用和管理</strong>：缓冲池将多个缓冲区统一管理起来，可以根据需要动态分配给不同的 I/O 操作，提高了内存资源的利用率。</li></ol><p>引入缓冲池后，系统处理 I/O 设备和 CPU 间的数据输送的方式如下：</p><ul><li><strong>数据输入</strong>：当数据从 I/O 设备传入时，系统首先将数据写入缓冲池中的一个空闲缓冲区。如果 CPU 需要这些数据，它可以快速地从缓冲池中读取，而不需要直接等待 I/O 设备。数据完全写入缓冲区后，I/O 设备可以继续其操作，同时 CPU 收到通知（如通过中断）来处理缓冲区中的数据。</li><li><strong>数据输出</strong>：当 CPU 需要将数据发送到 I/O 设备时，数据先被写入缓冲池。一旦缓冲区填满或达到特定条件，系统会调度数据从缓冲区传输到 I/O 设备，同时 CPU 可以继续执行其他任务。这减少了 CPU 等待 I/O 设备完成传输的时间。</li><li><strong>缓冲区管理</strong>：系统需要维护一个机制来跟踪缓冲区的状态（空闲、正在填充、正在提取数据等），以及高效地分配和回收缓冲区。缓冲池通常采用队列或其他数据结构来组织和管理这些缓冲区。</li></ul></blockquote></li><li><p>缓冲池的工作方式及 Getbuf 和 Putbuf 过程</p><blockquote><p>缓冲池的四种工作方式：</p><ol><li>收容输入</li><li>提取输入</li><li>收容输出</li><li>提取输出</li></ol><p>缓冲池（Buffer Pool）是一种内存区域，主要用于存储从慢速存储设备（如磁盘）读取的数据或等待写回慢速存储设备的数据。其目的是利用内存的高速访问特性，减少对慢速存储的直接访问，提高系统性能。以下是缓冲池的一般工作方式及 Getbuf 和 Putbuf 过程的概述：</p><h3 id="缓冲池的工作方式"><a class="markdownIt-Anchor" href="#缓冲池的工作方式">#</a> 缓冲池的工作方式：</h3><ol><li><strong>数据读取</strong>：<ul><li>当系统需要读取数据时，首先检查所需数据是否已经在缓冲池中。如果是，则直接从缓冲池读取，这称为 “缓存命中”。</li><li>如果数据不在缓冲池中（缓存未命中），系统会从磁盘读取数据到缓冲池的一个空闲缓冲区中，并记录此缓冲区的状态。之后，CPU 可以直接从缓冲池中获取数据。</li><li>在缓冲池空间有限的情况下，可能需要根据某种替换策略（如 LRU，Least Recently Used）选择一个缓冲区，将其内容写回磁盘以腾出空间给新数据。</li></ul></li><li><strong>数据写入</strong>：<ul><li>写操作通常也是先写入缓冲池，而不是直接写入磁盘。这称为 “延迟写” 策略。</li><li>数据在缓冲池中被标记为 “脏” 的，表示它已被修改且尚未持久化到磁盘。</li><li>当缓冲区被标记为脏或者按照一定策略（如定时、缓冲区满）需要刷新时，数据会被写回磁盘。</li></ul></li></ol><h3 id="getbuf和putbuf过程"><a class="markdownIt-Anchor" href="#getbuf和putbuf过程">#</a> Getbuf 和 Putbuf 过程：</h3><p>这两个过程常用于描述多进程环境下对缓冲池中缓冲区的分配和回收操作，以确保资源的安全共享和避免冲突。这些过程通常涉及信号量机制以实现互斥和同步。</p><ul><li><strong>Getbuf 过程</strong>： 当进程需要从缓冲池中获取一个缓冲区来读取或写入数据时，执行 Getbuf 过程：<ol><li><strong>检查资源</strong>：进程首先尝试减少资源信号量 RS (type)，以确认是否有可用的缓冲区。</li><li><strong>互斥访问</strong>：如果资源可用，减少互斥信号量 MS (type) 以获得对缓冲池的独占访问权。</li><li><strong>分配缓冲区</strong>：从缓冲池中选择一个合适的缓冲区并标记其状态。</li><li><strong>释放互斥</strong>：完成后，增加 MS (type) 信号量，允许其他进程访问缓冲池。</li></ol></li><li><strong>Putbuf 过程</strong>： 当进程完成对缓冲区的使用后，执行 Putbuf 过程归还缓冲区：<ol><li><strong>更新状态</strong>：将缓冲区状态更新为可用或脏（如果数据被修改）。</li><li><strong>释放资源</strong>：增加资源信号量 RS (type)，表明有一个缓冲区已经可用给其他进程使用。</li></ol></li></ul></blockquote></li><li><p>设备独立性：什么是设备独立性，如何实现设备独立性，设备驱动程序（了解）</p><blockquote><ol><li>设备独立性的概念：设备独立性的概念为了提高 OS 的可适应性和可扩展性，在现代 OS 中都毫无例外地实现了设备独立性 (Device Independence)，也称为设备无关性。其基本含义是: <strong>应用程序独立于具体使用的物理设备。</strong></li><li>设备独立性软件的主要功能可分为以下两个方面：(1) 执行所有设备的公有操作。(2) 向用户层 (或文件层) 软件提供统一接口</li></ol></blockquote></li><li><p>虚拟设备：什么是虚拟设备，实现虚拟设备的关键技术（了解）</p><p>（1）设备的固有属性</p><p>​	独占性。独占设备是不能同时共用的设备，即在一段时间内，该设备只允许一个进程独占。临界资源</p><p>​	共享性。允许多个进程同时共享</p><p>​	可虚拟性。虚拟设备是利用某种技术把独占设备改造成可由多个进程共享的设备</p><p>（2）设备分配算法</p><p>​	先来先服务</p><p>​	优先级高者优先</p></li><li><p><strong>设备驱动程序</strong>与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动 I/O 设备工作的驱动程序。</p></li><li><p>SPOOLing 技术，SPOOLing 技术的组成，如何利用 SPOOLing 技术实现共享打印机（了解）</p><blockquote><p>在主机的直接控制下，实现脱机输入、输出功能。此时的外围操作与 CPU 对数据的处理同时进行，我们把这种在联机情况下实现的同时外围操作称为 SPOOLing（Simultaneaus Periphernal Operating On Line），或称为假脱机操作。</p><p>其工作原理为：①在磁盘中开辟若干区域，形成 “共享设备”，当某作业或进程请求分配独占设备时，系统就分配给它共享设备中的某一部分，使其与独占设备相关联。②在用户申请独占设备时，用户实际得到的是磁盘上的一块区域。③采用 “预输入” 和 “缓输出” 策略，以提高低速、独占设备的利用率。</p></blockquote></li><li><p>磁盘调度的目标，磁盘访问时间的计算，FCFS、SSTF、SCAN、CSCAN 等算法的应用；各算法的性能比较</p></li></ol><h2 id="文件管理"><a class="markdownIt-Anchor" href="#文件管理">#</a> 文件管理</h2><ol><li><p>文件的逻辑结构：顺序文件、索引文件和索引顺序文件，原理和特征，组织方式、访问方法及各种文件形式的比较</p><blockquote><ol><li>顺序文件，指由一系列记录按某种顺序排列所形成的文件，其中的记录可以是定长记录或可变长记录。<strong>批量存取时效率高；但是单个记录查改性能差，长度限制，增加或删除困难</strong></li><li>索引文件，指为可变长记录文件建立一张索引表，为每个记录设置一个表项，以加速对记录的检索速度。<strong>对单个文件的查找、插入和删除速度快，但索引增加了存储开销。</strong></li><li>索引顺序文件，这是顺序文件和索引文件相结合的产物，这里，在为每个文件建立一张索引表时，并不是为每一个记录建立一个索引表项，而是为一组记录中的第一个记录建立一个索引表项。</li></ol></blockquote></li><li><p>(文件的物理结构) 外存分配方式：连续分配、链接分配和索引分配原理、优缺点（显示链接 FAT、增量式索引分配）</p><blockquote><ol><li><p><strong>连续分配</strong>要求为每一个文件分配<strong>一组相邻接的盘块</strong>。一组盘块的地址定义了磁盘上的一段线性地址。把逻辑文件中的数据顺序地存储到物理上邻接的各个数据块中，这样形成的物理文件可以进行顺序存取。文件目录中为每个文件建立一个表项，其中记载文件的第一个数据块地址及文件长度。对于顺序文件，连续读 / 写多个数据块内容时，性能较好。</p><ul><li>连续分配的主要优点：（1）<strong>顺序访问容易</strong>。 能很快检索文件中的一个数据块。(2) 顺序访问<strong>速度快</strong>。<strong>磁头</strong>移动距离短，效率最高</li><li>缺点：（1）要求有<strong>连续的</strong>存储空间。 该分配方案可能会导致磁盘碎片，严重降低外存空间的利用率。(2) 必须<strong>事先知道文件的长度</strong>。空间利用率不高；(3) <strong>不能灵活的删除和插入数据</strong> (4) 不利于文件尺寸的<strong>动态增长</strong>。</li></ul></li><li><p><strong>链接文件</strong>：采用链接分配方式时，可通过在每个盘块上的链接指针，将<strong>同属于一个文件的多个离散的盘块</strong>链接成一个<strong>链表</strong>，把这样形成的物理文件称为链接文件。</p><p>优点：<strong>消除了磁盘的外部碎片</strong>，提高了外存的利用率；对<strong>插入、删除和修改</strong>记录都非常容易；能适应文件的<strong>动态增长</strong></p><ul><li><strong>隐式链接</strong>：在采用隐式链接分配方式时，在文件目录的每个目录项中，都须含有指向链接文件第一个盘块和最后一个盘块的指针。每个盘块中都含有一个指向下一个盘块的指针。<strong>隐式链接分配方式的主要问题在于：它只适合于顺序访问，它对随机访问是极其低效的。</strong></li><li><strong>显式链接</strong>：这是指把用于链接文件各物理块的指针，显式地存放在内存的一张<strong>链接表</strong>中。整个磁盘仅设置一张<strong>文件分配表（FAT）</strong>。<ul><li>在该表中，凡是属于某一文件的第一个盘块号，均作为文件地址被填入相应文件的 FCB 的 “物理地址” 字段中。</li><li>查找记录的过程是在内存中进行的，因而<strong>不仅显著地提高了检索速度，而且大大减少了访问磁盘的次数。</strong></li><li>由于分配给文件的所有盘块号都放在该表中，故把该表称为<strong>文件分配表 FAT</strong> (File Allocation Table)。</li></ul></li></ul></li><li><p><strong>索引分配</strong></p><p>1、利用专门的索引块存储索引信息<br>2、一个数据块容纳不了一个文件的所有分区时，<br>需要若干个索引结点进行存储，建立二级<br>索引或多级索引。</p></li><li><p><strong>单级索引分配</strong>：索引分配能解决连续分配和链接分配存在的诸多问题。原理：为每个文件分配一个索引块 (表)，再把分配给该文件的所有盘块号都记录在该索引块中，因而该索引块就是一个含有许多盘块号的数组。在建立一个文件时，只需在为之建立的目录项中填上指向该索引块的指针。</p><ul><li>优点：索引分配方式支持直接访问。基于数据块的分区能消除外部碎片</li><li>缺点：索引块可能要花费较多的外存空间。每当建立一个文件时，便须为之分配一个专门的索引块，将分配给该文件的所有盘块号记录于其中。对于小文件如果采用这种方式，索引块的利用率将是极低的。大文件索引项较多，可能使一个数据块容纳不了一个文件的所有分区的索引。</li></ul></li><li><p><strong>多级索引分配</strong>，<strong>增量式索引分配</strong></p></li><li><p><strong>混合索引方式</strong></p></li></ol></blockquote></li><li><p>目录管理：目录管理的要求，文件控制块（FCB）索引结点，目录结构：单级、两级和多级</p><blockquote><p>目录管理的要求：</p><ul><li>实现 “<strong>按名存取</strong>”</li><li>提高对目录的<strong>检索速度</strong></li><li>文件<strong>共享</strong></li><li>允许文件<strong>重名</strong></li></ul><p><strong>文件控制块（FCB）</strong>：用于描述和控制文件的数据结构</p><p>文件目录：文件控制块的有序集合。</p><p>索引节点：把文件名和文件描述信息分开，使文件描述信息单独形成一个成为索引节点的数据结构</p><p>目前广泛采用的目录结构是<strong>树形目录结构</strong>，具体形式多样，但大多基于以下几种模型或其变体：</p><ul><li><strong>单级目录结构</strong>：早期系统中使用，所有文件都在同一层次下，但现代系统已很少采用，因为它不满足易用性和可扩展性的需求。</li><li><strong>两级目录结构</strong>：将文件系统分为用户文件目录和系统文件目录，尽管有所改进，但仍然不能很好地支持大规模文件组织。</li><li><strong>树形目录结构（多级目录）</strong>：这是当前操作系统普遍采用的目录结构。每个目录可以包含文件和子目录，形成一个倒置的树状结构。根目录位于顶部，其他目录和文件作为分支和叶子节点。这种结构支持无限层级的嵌套，易于组织和查找文件，同时也便于实现权限控制和资源共享。</li></ul><p>树形目录结构的优点包括：</p><ul><li><strong>灵活的文件组织</strong>：用户可以根据需要创建多级目录，便于分类和管理文件。</li><li><strong>高效的搜索和访问</strong>：通过路径名可以直接定位文件，且现代系统常采用缓存等技术加速目录查找。</li><li><strong>权限控制</strong>：可以为不同目录设置不同的访问权限，增强系统的安全性和隐私保护。</li><li><strong>易于维护和扩展</strong>：随着文件数量的增长，可以通过增加目录层级来管理，不会导致系统性能的线性下降。</li><li><strong>兼容性和标准化</strong>：大多数操作系统（如 Windows, Linux, macOS）都采用了类似的树形目录结构，便于跨平台操作和数据交换。</li></ul><p><em>在 Linux 中：</em></p><p>UNIX 文件管理 (重点)<br>Linux 中用<strong> EXT2</strong> 文件系统结构<br>在<strong> EXT2</strong> 文件系统中，查找文件的过程:</p><ul><li>当访问一个文件时，通过<strong>文件名</strong>在 “<strong>目录表</strong>” 中查到其 “<strong>索引节点号</strong> &quot;</li><li>通过 “索引节点<strong>号</strong> &quot;查&quot; 索引节点<strong>表</strong>”。</li><li>通过 “索引节点<strong>表</strong>” 得到其 “索引<strong>节点</strong>”。</li><li>通过索引<strong>节点</strong>得到文件数据所在<strong>位置</strong></li></ul><p>需要学会如何根据 Inode 信息，计算系统支持的最大文件大小</p><ul><li><p>6 种文件类型：普通文件、目录文件、特殊文件、命名管道、链接文件、符号链接</p></li><li><p>文件分配单位：块</p></li><li><p>分配方式：动态按需分配</p></li><li><p>文件组成<br>Linux 文件系统的一个文件由目录项、inode 和数据块组成</p></li><li><p><strong>目录项</strong>：包括文件名和 inode 节点号</p></li><li><p><strong>Inode</strong>: 又称文件索引节点，是文件基本信息的存放地和数据块指针存放地</p></li><li><p><strong>数据块</strong>：文件的具体内容存放地</p></li></ul><p>Inode： 索引节点，包含操作系统所需的某个文件的关键信息，UNIX 系统中的文件分配表</p><ol><li><p><em>目录文件内容：一系列目录项（dirent）的列表，每个目录项由两部分组成：<strong>所包含文件的文件名；文件名对应的索引节点（inode）号</strong></em></p></li><li><p>文件在内核中的表现形式：文件描述符表，文件表，索引节点</p></li></ol><p><strong>单级目录结构</strong>：所有用户的全部文件目录保存在一张目录表中，每个文件的目录项占用一个表项。</p><ul><li>单级目录的优点是简单且能实现目录管理的基本功能 —— 按名存取</li><li>存在下述一些缺点： (1) 查找速度慢 (2) 不允许重名 (3) 不便于实现文件共享</li></ul><p><strong>两级目录结构</strong>：主文件目录 MFD、用户文件目录 UFD</p><ul><li><p>提高了检索目录的速度</p><p>・由 n*m 提高到 n+m</p><pre><code> 在不同的 UFD 中，可以使用相同的文件名
                
不同用户可以使用不同的文件名访问系统中的同一个共享文件
                
 用户间的隔离使文件共享不方便
                
- 要让不同用户使用不同的文件名访问系统中的同一个共享文件，可以通过在MFD中设置一个特殊条目来指向共享文件的实际位置，然后在需要访问该共享文件的用户的UFD中创建一个链接或别名（可能是硬链接或符号链接的形式），这个链接指向MFD中共享文件的条目。这样，每个用户看到的是自己UFD中的文件名，但实际上指向的是同一个物理文件。
</code></pre><ul><li><strong>用户间的隔离使文件共享不方便</strong>：虽然实现了基本的共享，但权限管理和访问控制较为简陋，难以精细化控制不同用户对共享文件的访问权限。<ul><li><strong>文件如何共享？</strong>：改进方法包括引入权限系统，允许系统管理员或文件所有者设定共享文件的访问权限（读、写、执行等），并在 UFD 中通过链接明确标识出哪些文件是共享的，并附带相应的访问控制信息。随着技术发展，现代文件系统（如 NTFS、Ext4 等）采用了多级目录结构、访问控制列表（ACL）、用户组等高级功能，极大地丰富了文件共享和权限管理的能力。</li></ul></li></ul></li></ul><p><strong>多级目录结构</strong>：</p><pre><code>  （1）目录结构：多级目录结构又称为树型目录结构，主目录在这里被称为根目录，把数据文件称为树叶，其它的目录均作为树的结点。
        
  （2）路径名：从树的根（即主目录）开始，把全部目录文件名与数据文件名，依次地用“/”连接起来，即构成该数据文件的路径名（path name）。系统中的每一个文件都有惟一的路径名。
        
  （3）当前目录：为每个进程设置一个“当前目录”，又称为“工作目录”进程对各文件的访问都相对于“当前目录”而进行。
</code></pre></blockquote></li><li><p>文件磁盘空间管理：空闲表法和空闲链法，位示图法：分配和回收的具体计算</p><blockquote><ol><li><p><strong>空闲分区表</strong>：空闲表法属于<strong>连续分配方式</strong>，它为每个文件分配一块连续的存储空间，即系统也为外存上的所有空闲区建立一张空闲表，每个空闲区对应于一个空闲表项，其中包括表项序号、该空闲区的第一个盘块号、该区的空闲盘块数等信息。<strong>适合于可变大小分区的连续分配方式。</strong></p></li><li><p><strong>空闲链表法</strong>是将所有空闲盘区拉成一条空闲链。根据构成链所用基本元素的不同，可把链表分成两种形式：空闲盘块链、空闲盘区链</p><ul><li><strong>空闲盘块链</strong>：将磁盘上的所有空闲空间，以盘块为单位<strong>拉成一条链</strong>。当用户因创建文件而请求分配存储空间时，系统从链首开始，依次摘下适当数目的空闲盘块分配给用户。当用户因删除文件而释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾。</li><li><strong>空闲盘区链</strong>：将磁盘上的所有空闲盘区 (每个盘区可包含若干个盘块) 拉成一条链。在每个盘区上含有用于指示下一个空闲盘区的指针和能指明本盘区大小 (盘块数) 的信息。分配盘区的方法与内存的动态分区分配类似，通常采用首次适应算法。在回收盘区时，同样也要将回收区与相邻接的空闲盘区相合并。</li></ul></li><li><p><strong>位示图</strong>：利用二进制位 0、1 表示存储空间中存储块的使用状态。空闲分区：0，已分配分区：1（或者相反）。磁盘上的所有盘块都有一个二进制位与之对应，这样，由所有盘块所对应的位构成一个集合，称为位示图。通常可用 m × n 个位数来构成位示图，并使 m × n 等于磁盘的总块数。</p><p>ü 顺序扫描位示图，从中找出一个值为 “0” 的二进制位（空闲位）</p><p>ü 将所找到的空闲位号转换成与之相应的空闲块号： 　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　b=n*(i-1)+j</p><p>b 为对应的空闲块的块号</p><p>n 为位示图中每行的位数</p><p>i、j 分别为空闲位在位示图的行号、列号</p><p>修改位示图：令 map [i,j]＝1</p><p>③盘块的回收</p><p>ü 将回收盘块的盘块号转换成位示图中的行</p><p>号和列号</p><p>​ i=(b-1)/ n + 1</p><p>j=(b-1)% n + 1</p><p>ü 修改位示图：令 map [i,j]＝0</p></li></ol></blockquote></li></ol><h2 id="unixlinux入门"><a class="markdownIt-Anchor" href="#unixlinux入门">#</a> <strong>Unix/Linux</strong> 入门</h2><h3 id="什么是shell"><a class="markdownIt-Anchor" href="#什么是shell">#</a> 什么是 SHELL</h3><ul><li><p>Shell 是系统的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclOTQlQTglRTYlODglQjclRTclOTUlOEMlRTklOUQlQTI=">用户界面</span>，提供了用户与<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODYlODUlRTYlQTAlQjg=">内核</span>进行交互操作的一种<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEUlQTUlRTUlOEYlQTM=">接口</span>。它接收用户输入的命令并把它送入内核去执行。</p></li><li><p>Shell 是一个命令<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQTclQTMlRTklODclOEElRTUlOTklQTg=">解释器</span>，它解释由用户输入的命令并且把它们送到内核。</p></li><li><p>Shell 是一个解释型的程序设计语言。</p></li></ul><h3 id="简单命令"><a class="markdownIt-Anchor" href="#简单命令">#</a> 简单命令</h3><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-202406182232009553.png" alt="image-202406182232009553"></p><h4 id="输入输出重定向-grep"><a class="markdownIt-Anchor" href="#输入输出重定向-grep">#</a> 输入 / 输出重定向 ：grep</h4><p>command &gt; filename command &gt;&gt; filename</p><p>command &lt; filename command &lt;&lt; filename</p><h4 id="管道-command1-command2"><a class="markdownIt-Anchor" href="#管道-command1-command2">#</a> 管道 command1 | command2</h4><p>◦例如：$ ps –e | grep student2</p><p>shell 环境变量 env</p><p>echo 命令的使用</p><p>系统变量:<em> 系统变量只能引用不能修改！</em></p><p>单引号、双引号、反撇号和花括号</p><ul><li>单引号禁止变量替换，元字符 $ 和 * 等保持其符号本身；而双引号允许元字符变量替换.</li><li>反撇号中的字符串作为命令名执行</li><li>花括号将变量名和后面的字符串区分开</li></ul><h2><a class="markdownIt-Anchor" href="#">#</a></h2><p>shell 编程：功能性语句、结构性语句和说明性语句.</p><p>read, expr,test 等</p><pre><code>#!/bin/sh
# Put  line  numbers  on  all  lines  of  a  file 
if [ $#  -ne  1 ]
then
       echo  &quot;Usage: $0  filename &quot;  &gt;&amp;2
       exit 1
fi
count=1                     # Initialize count
cat  $1  |  while  read  line   
# Input is coming from file on command line
do
    echo  $count  $line
    count=`expr $count + 1`
done  &gt;  tmp$$           # Output is going to a temporary file
mv  tmp$$  $1

</code></pre><p>功能：给一个文本文件中的每一行前面加上行号。</p><p>注意：while 循环体的标准输入，被重定向为从管道中读。</p><p>while 循环体的标准输出，被重定向到了 tmp$$ 文件中，这里的 $$ 就是当前进程的进程号，因为进程号的唯一性，所以多个用户同时运行该程序时，不会相互覆盖！</p>当前进程的ID号 $# 命令行上的参数个数 ## **文件操作与权限管理** 目录文件内容：一系列目录项（dirent）的列表，每个目录项由两部分组成：所包含文件的文件名；文件名对应的索引节点（inode）号 Linux内核通过一个被称为进程描述符的task_struct结构体来管理进程，这个结构体包含了一个进程所需的所有信息。 文件的打开和关闭都是资源的一种操作，Linux中的task_struct中有两个结构体存储这两个信息。 Sruct fs_struct *fs：进程的可执行映象所在的文件系统，有两个索引点，称为root和pwd，分别指向对应的根目录和当前目录。 Struct files_struct *files：进程打开的文件, 指向files_struct结构体, 称为文件描述符表 已打开的文件在Linux内核中用file结构体表示,文件描述符表中的指针fd[ ]指向一个已打开文件的file结构体 在file结构体中比较重要的成员包括File Status Flag(f_flags)和当前读写位置(f_pos )还有f_count,表示引用计数(Reference Count), 每个file 结构体都指向一个file_operations 结构体,这个结构体的成员都是函数指针,指向实现各种文件操作的内核函数。 ![image-20240618223645538](https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240618223645538.png) 每个进程在PCB中有一个文件描述符表，每个描述符表项指向一个文件表 内核为每一个被该进程使用（打开）的文件维护一张文件表file 每个文件（或设备）都有一个索引节点，它包含了文件类型属性及文件数据 ![image-20240618223658104](https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240618223658104.png) ![image-20240618223711048](https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240618223711048.png) ![image-20240618223720676](https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-202406182237206765.png) ![image-20240618223734383](https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240618223734383.png)<div class="tags"><a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="ic i-tag"></i> 学习</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-08-03 20:08:47" itemprop="dateModified" datetime="2024-08-03T20:08:47+08:00">2024-08-03</time> </span><span id="2024/06/20/os/" class="item leancloud_visitors" data-flag-title="操作系统复习" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Tviak <i class="ic i-at"><em>@</em></i>Tviak的普通观测站</li><li class="link"><strong>本文链接：</strong> <a href="https://blog.tviakowo.live/2024/06/20/os/" title="操作系统复习">https://blog.tviakowo.live/2024/06/20/os/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/06/20/qt/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;TV233&#x2F;blogpic@master&#x2F;img&#x2F;87825932_p0~1.jpg" title="C++ &amp; Qt 复习笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>C++ & Qt 复习笔记</h3></a></div><div class="item right"><a href="/2024/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;TV233&#x2F;blogpic@master&#x2F;img&#x2F;87825932_p0~1.jpg" title="数据库复习"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>数据库复习</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">操作系统引论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">处理机管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">存储器管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">缓冲池的工作方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getbuf%E5%92%8Cputbuf%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">Getbuf 和 Putbuf 过程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">文件管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unixlinux%E5%85%A5%E9%97%A8"><span class="toc-number">6.</span> <span class="toc-text">Unix&#x2F;Linux 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFshell"><span class="toc-number">6.1.</span> <span class="toc-text">什么是 SHELL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4"><span class="toc-number">6.2.</span> <span class="toc-text">简单命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91-grep"><span class="toc-number">6.2.1.</span> <span class="toc-text">输入 &#x2F; 输出重定向 ：grep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-command1-command2"><span class="toc-number">6.2.2.</span> <span class="toc-text">管道 command1 | command2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text"></span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Tviak" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Tviak</p><div class="description" itemprop="description">观测世界和自己的一般通过观测者</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">54</span> <span class="name">文章</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>主页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/06/20/qt/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A01/" title="软件工程复习">软件工程复习</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2020/03/18/%E5%A5%BD%E5%83%8F%E5%BC%84%E5%A5%BD%E4%BA%86/" title="233">233</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/03/03/%E7%88%AC%E8%99%AB%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%9E%E6%88%98/" title="爬虫，但是实战">爬虫，但是实战</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/28/GitHub/" title="GitHub 学生包 Proof Type 选项消失解法">GitHub 学生包 Proof Type 选项消失解法</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/08/16/practise/" title="HTML 语义化的案例分析">HTML 语义化的案例分析</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/03/03/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E4%BD%86%E6%98%AF%E5%90%83%E7%81%B0/" title="Linux虚拟机，但是吃灰">Linux虚拟机，但是吃灰</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/03/03/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%BD%86%E6%98%AF%E5%88%9D%E5%AD%A6/" title="数据库，但是初学">数据库，但是初学</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/08/06/%E7%88%B1%E6%80%9D%E8%87%AA%E7%AD%BE%E9%97%AE%E9%A2%98/" title="爱思自签问题">爱思自签问题</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/10/11/clone%E9%97%AE%E9%A2%98/" title="使用dev-sidecar解决git clone问题">使用dev-sidecar解决git clone问题</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/10/13/20241013/" title="记阿里云效flow镜像构建推送403问题+docker部署到ecs报错问题">记阿里云效flow镜像构建推送403问题+docker部署到ecs报错问题</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Tviak @ Tviak's Observatory</span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">214k 字</span> <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:52</span></div><p id="hitokoto"><a href="#" id="hitokoto_text">:D 获取中...</a></p><script>fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      const hitokoto = document.querySelector('#hitokoto_text')
      hitokoto.href = `https://hitokoto.cn/?uuid=${data.uuid}`
      hitokoto.innerText = data.hitokoto
    })
    .catch(console.error)</script><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span><br><a href="https://icp.gov.moe/?keyword=20237705" target="_blank">萌ICP备20237705号</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/06/20/os/",favicon:{show:"（●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://polyfill.alicdn.com/polyfill.min.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>