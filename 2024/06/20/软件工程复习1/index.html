<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Tviak的普通观测站" href="https://blog.vktia.me/rss.xml"><link rel="alternate" type="application/atom+xml" title="Tviak的普通观测站" href="https://blog.vktia.me/atom.xml"><link rel="alternate" type="application/json" title="Tviak的普通观测站" href="https://blog.vktia.me/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="学习"><link rel="canonical" href="https://blog.vktia.me/2024/06/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A01/"><title>软件工程复习 | Tviak's Observatory = Tviak的普通观测站 = 跨出自己的舒适区很难，但跨出去了就是成长。</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">软件工程复习</h1><div class="meta"><span class="item" title="创建时间：2024-06-20 19:31:09"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-06-20T19:31:09+08:00">2024-06-20</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>10k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Tviak's Observatory</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/TV233/blogpic@master/img/84179374_p0.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/TV233/blogpic@master/img/82421582_p01.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/TV233/blogpic@master/img/87825932_p0~1.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/TV233/blogpic@master/img/77414471_p10.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/TV233/blogpic@master/img/99384307_p0.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/TV233/blogpic@master/img/96593703z_p0.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.vktia.me/2024/06/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A01/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Tviak"><meta itemprop="description" content="跨出自己的舒适区很难，但跨出去了就是成长。, 观测世界和自己的一般通过观测者"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Tviak的普通观测站"></span><div class="body md" itemprop="articleBody"><h1 id="1-软件工程概述"><a class="markdownIt-Anchor" href="#1-软件工程概述">#</a> 1 软件工程概述</h1><h3 id="软件的概念"><a class="markdownIt-Anchor" href="#软件的概念">#</a> 软件的概念</h3><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/d7e14b31efd24417a12dec8dadbdd18b.png" alt="img"></p><p>程序应该不陌生，就是编程一系列指令使能够实现预期的功能，这是软件的基础；</p><p>数据是程序的数据结构和信息，不是所有程序都需要数据库，但一定都有数据结构；</p><p>文档类似<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTUlQkMlODAlRTUlOEYlOTElRTYlOTYlODclRTYlQTElQTMmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">开发文档</span>，包括软件的设计、开发、功能、维护等等。</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/ccfd24cdd9ee4e13907d49015a661b43.png" alt="img"></p><p>上图是软件的结构示意图，可执行部分只有程序，而数据和文档都是支撑软件完整性的作用。</p><h3 id="软件的特点"><a class="markdownIt-Anchor" href="#软件的特点">#</a> 软件的特点</h3><blockquote><p>软件是逻辑的，而不是物理的。</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/5a78a72dc4004bff9b5dd7d3f442bdee.png" alt="img"></p><p>软件是逻辑的而不是物理的，说明软件的<strong>复杂性、难以描述性、不可见性、变化性</strong>。</p><h3 id="软件危机的概念和产生的原因"><a class="markdownIt-Anchor" href="#软件危机的概念和产生的原因">#</a> 软件危机的概念和产生的原因</h3><blockquote><p>在计算机软件的开发和维护过程中所遇到的一系列严重问题。</p></blockquote><p><strong>严重问题：多指效率和质量上的问题。</strong></p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/47ed2d018b0c49cab203b61338853998.png" alt="img"></p><p>可以总结为： <strong>周期长、成本高、质量差、维护难。</strong></p><h3 id="软件工程的定义-三要素-应用软件工程的原因"><a class="markdownIt-Anchor" href="#软件工程的定义-三要素-应用软件工程的原因">#</a> 软件工程的定义、三要素、应用软件工程的原因</h3><p>软件工程的定义</p><blockquote><p>IEEE 计算机协会将软件工程定义为:（1) 将系统化的、科学化的、可量化的方法应用于软件的开发、运行和维护，即针对软件的工程应用。(2) 对上述应用方法的研究</p></blockquote><p>三要素：方法、工具、过程</p><p>应用软件工程的原因：软件工程的应用主要是为了提高软件产品的质量和开发效率，减少维护的困难，并解决软件开发中的各种问题。它可以帮助我们更好地分解和解决复杂的软件开发问题。总的来说，应用软件工程的原因主要是为了应对所谓的 “软件危机”。</p><h1 id="2-软件过程"><a class="markdownIt-Anchor" href="#2-软件过程">#</a> 2 软件过程</h1><h3 id="软件生命周期概念"><a class="markdownIt-Anchor" href="#软件生命周期概念">#</a> 软件生命周期概念</h3><p>软件产品或软件系统从设计、投入使用到被淘汰的全过程</p><h3 id="软件过程概念"><a class="markdownIt-Anchor" href="#软件过程概念">#</a> 软件过程概念</h3><p>软件过程是在工作产品构建过程中，所需完成的工作活动、动作和任务的集合</p><p>活动：主要实现宽泛的目标，与应用领域、项目大小、结果复杂性或者实施软件工程的重要程度没有直接关系。<br>动作：包含了主要工作产品生产过程中的一系列任务。<br>任务：关注小而明确的目标，能够产生实际产品。</p><h3 id="软件过程模型"><a class="markdownIt-Anchor" href="#软件过程模型">#</a> <span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTglQkQlQUYlRTQlQkIlQjYlRTglQkYlODclRTclQTglOEIlRTYlQTglQTElRTUlOUUlOEImYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">软件过程模型</span>的定义</h3><blockquote><p>软件过程模型是软件开发全部过程、活动和任务的<strong>结构框架</strong>。它能直观表达软件开发全过程，明确规定要完成的主要活动、任务和开发策略。软件过程模型也常称为:<br>软件开发模型<br>软件生存周期模型<br>软件工程范型</p></blockquote><blockquote><p>常见的软件过程模型</p><ul><li>瀑布模型 (经典的生命周期模型)</li><li>演化过程模型<ul><li>原型模型</li><li>并行开发模型</li></ul></li><li>增量过程模型<ul><li>增量模型</li><li>RAD</li><li>螺旋模型</li></ul></li><li>其他过程模型<ul><li>基于构件模型</li><li>智能模型</li><li>敏捷过程模型</li></ul></li></ul></blockquote><hr><h3 id="软件工程的中心与三要素"><a class="markdownIt-Anchor" href="#软件工程的中心与三要素">#</a> 软件工程的中心与三要素</h3><blockquote><p>软件工程的中心：<strong>质量</strong></p><p>软件工程三要素：<strong>方法、工具、过程</strong></p></blockquote><p>方法是完成软件开发的各项任务的技术方法，为软件开发提供技术；</p><p>工具是为运用方法而提供的自动或半自动的软件工程的支撑环境；</p><p>过程是为了获得高质量软件而所需要完成的一系列任务的框架。</p><p>常见的几种软件过程模型：瀑布、增量、原型、螺旋、敏捷等，比较各自优缺点</p><h3 id="软件生存期模型"><a class="markdownIt-Anchor" href="#软件生存期模型">#</a> 软件生存期模型</h3><h4 id="瀑布模型"><a class="markdownIt-Anchor" href="#瀑布模型">#</a> <span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTclODAlOTElRTUlQjglODMlRTYlQTglQTElRTUlOUUlOEImYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">瀑布模型</span></h4><p>软件生命周期：软件产品或软件系统从设计、投入使用到被淘汰的全过程</p><p>瀑布模型：软件开发过程与软件生命周期是一致的，也称经典的生命周期模型。它规定了各项软件工程活动，以及它们自上而下，相互衔接的固定次序，如同瀑布流水，逐级下落，是一种使用广泛，以文档为驱动的模型。</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/c92cc76fd6204042898d07149271645a.png" alt="img"></p><blockquote><p>优点</p><ul><li>简单，过程透明性高，过程可管理性高</li><li>推迟实现，软件实现前必须进行系统分析和设计工作</li><li>以阶段评审和文档控制为手段进行质量控制，能够及时发现并纠正软件缺陷，能够达到预期质量要求</li></ul><p>缺点</p><ul><li>模型灵活性差，不适合需求不明确或准确的场合</li><li>模型风险控制能力弱</li><li>过多的文档增加了工作量，当技术具有不确定性情况下完全以文档来评估项目进度时会产生错误的结论</li></ul><p>适用场合</p><ul><li>瀑布模型适用于系统需求明确、技术成熟、工程管理较严格的场合。</li></ul></blockquote><h4 id="快速原型模型"><a class="markdownIt-Anchor" href="#快速原型模型">#</a> <span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTUlQkYlQUIlRTklODAlOUYlRTUlOEUlOUYlRTUlOUUlOEIlRTYlQTglQTElRTUlOUUlOEImYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">快速原型模型</span></h4><p>快速原型是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往<strong>是最终产品能完成的功能的一个子集</strong>。快速原型模型是增量模型的另一种形式，在开发真实系统之前迅速建造一个可以运行的软件原型 ，以便理解和澄清问题，在该原型的基础上，<strong>逐渐完成</strong>整个系统的开发工作。</p><p>它允许在需求分析阶段对软件的需求进行<strong>初步而非完全</strong>的分析和定义，快速设计开发出软件系统的原型，该原型向用户展示待开发软件的全部或部分功能和性能；用户对该原型进行测试评定，给出具体改进意见以<strong>丰富细化</strong>软件需求；开发人员据此对软件进行<strong>修改完善</strong>，直至用户满意认可之后，进行软件的<strong>完整实现及测试、维护。</strong></p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/27d0117ecae64945a62cc51ca69135a4.png" alt="img"></p><blockquote><p>优点</p><ul><li>克服瀑布模型的缺点，减少由于软件需求不明确带来的开发风险</li><li>适合预先不能确切定义需求的软件系统的开发</li></ul><p>缺点</p><ul><li>所选用的开发技术和工具不一定符合主流的发展；</li><li>快速建立起来的系统结构加上连续的修改可能会导致产品质量低下</li><li>使用前提是要有一个展示性的产品原型，一定程度上可能会限制开发人员的创新</li></ul><p>运用方式</p><p>由于运用原型的目的和方式不同，在使用原型时也采取不同的策略，有抛弃策略和附加策略。</p><ul><li>抛弃策略是将原型用于开发过程的某个阶段，促使该阶段的开发结果更加完整、准确、一致、可靠，该阶段结束后，原型随之作废。探索型和实验型就是采用此策略的。</li><li>附加策略是将原型用于开发的全过程，原型由最基本的核心开始，逐步增加新的功能和新的需求，反复修改反复扩充，最后发展为用户满意的最终系统，演化型快速原型就是采用此策略。</li></ul><p>采用何种形式、何种策略运用快速原型主要取决于软件项目的特点、人员素质、可供支持的原型开发工具和技术等，这要根据实际情况的特点来决定。</p></blockquote><h4 id="增量模型"><a class="markdownIt-Anchor" href="#增量模型">#</a> 增量模型</h4><p>增量模型结合了原型模型的基本要素和<strong>迭代</strong>的特征，采用了<strong>基于时间的线性序列</strong>，每个确定线性序列都会输出该软件的一个 “增量”</p><p>在前面增量的基础上开发后面的增量，<strong>每个增量的开发可用瀑布或快速原型模型和迭代</strong>的思路</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/9808bc446f1b467dbbaa8ae139d6e64a.png" alt="img"></p><blockquote><p>优点</p><ul><li>引入增量包概念，不需要提供完整的需求。只要有一个</li><li>增量包出现，开发就可以进行。</li><li>在项目的初始阶段不需要投入太多的人力资源。</li><li>增量可以有效地管理技术风险，降低系统失败风险。</li><li>有利于增加客户信心，提高系统可靠性、可维护性和稳定性。</li></ul><p>缺点</p><ul><li>增量粒度难以选择：每个增量必须提供一些系统功能，这使得开发者很难根据客户需求给出大小适合的增量。</li><li>确定所有的基本业务比较困难。</li></ul><p>适用场合</p><ul><li>进行已有产品升级或新版本开发，增量模型是非常适合的；</li><li>对完成期限严格要求的产品，可以使用增量模型；</li><li>对所开发的领域比较熟悉而且已有原型系统，增量模型也是非常适合的。</li></ul></blockquote><h4 id="螺旋模型"><a class="markdownIt-Anchor" href="#螺旋模型">#</a> 螺旋模型</h4><p>最早由 Boehm 提出，该模型结合了瀑布模型和原型模型的特点</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/431167e4b43141269db6b239a77c7241.png" alt="img"></p><p>螺旋模型沿着螺线旋转，在笛卡尔坐标的四个象限上分别表达了四个方面的活动</p><p>制定计划<br>- 确定软件目标，选定实施方案，弄清项目开发的限制条件</p><p>风险分析<br>- 分析所选方案，考虑如何识别和消除风险</p><p>实施工程<br>- 实施软件开发</p><p>客户评估<br>- 评价开发工作，提出修正建议</p><blockquote><p>优点</p><ul><li>支持用户需求的动态变化</li><li>原型可看作可执行的需求规格说明书，易于用户和开发人员共同理解，可作为继续开发的基础，为用户参与关键决策提供了方便</li><li>螺旋模型特别强调原型的可扩充性和可修改性，原型的进化贯穿整个软件生存周期，这将有助于目标软件的适应能力</li><li>螺旋模型为项目管理人员及时调整管理决策提供了方便，进而可降低开发风险</li></ul><p>缺点</p><ul><li>如果每次迭代的效率不高，致使迭代次数过多，将会增加成本并推迟提交时间；</li><li>使用该模型需要有相当丰富的风险评估经验和专门知识，要求开发队伍水平较高</li></ul><p>适用场合</p><p>支持需求不明确、特别是大型软件系统的开发，并支持面向规格说明、面向过程、面向对象等多种软件开发方法，是一种具有广阔前景的模型</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDIxMjUxNjY=">敏捷模型是一种软件开发模型，起源于美国，以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDIxMjUxNjY="> 1</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MDM5MDE1NDg=">2</span><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRjYXN0LmNuL25ld3MvMjAyMDEwMDgvMTYyMDQzODI1MDYuc2h0bWw=">3</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDIxMjUxNjY=">。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDIxMjUxNjY="> 1</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MDM5MDE1NDg=">2</span><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRjYXN0LmNuL25ld3MvMjAyMDEwMDgvMTYyMDQzODI1MDYuc2h0bWw=">3</span><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYWp1bjIzNTYwMzMvYXJ0aWNsZS9kZXRhaWxzLzgxNTEzOTU3">4</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDIxMjUxNjY=">。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDIxMjUxNjY="> 1</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MDM5MDE1NDg=">2</span><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRjYXN0LmNuL25ld3MvMjAyMDEwMDgvMTYyMDQzODI1MDYuc2h0bWw=">3</span><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYWp1bjIzNTYwMzMvYXJ0aWNsZS9kZXRhaWxzLzgxNTEzOTU3">4</span>。</p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MDM5MDE1NDg=">敏捷模型的优点包括更快交付价值，更低的风险，拥抱变化，更好的质量，持续改进，更高的客户满意度，更高的团队满意度，以及更大的灵活性</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MDM5MDE1NDg="> 2</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MDM5MDE1NDg=">。然而，敏捷模型也有其缺点，如很难进行准确的资源规划，很难准确地定义 “轻量的” 或必要的文档，很难把握整体产品的一致性，很难预测有限的终点，以及很难有效地进行度量</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MDM5MDE1NDg="> 2</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDIxMjUxNjY=">。总的来说，敏捷模型是一种高效的开发模式，适用于需要快速迭代和响应变化的项目</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDIxMjUxNjY="> 1</span><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MDM5MDE1NDg=">2</span><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRjYXN0LmNuL25ld3MvMjAyMDEwMDgvMTYyMDQzODI1MDYuc2h0bWw=">3</span><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYWp1bjIzNTYwMzMvYXJ0aWNsZS9kZXRhaWxzLzgxNTEzOTU3">4</span>。</p><h1 id="3-需求分析"><a class="markdownIt-Anchor" href="#3-需求分析">#</a> 3 需求分析</h1><p>需求分析的概念</p><blockquote><p>定义<br>对应用问题及环境的理解和分析，为问题涉及的信息、功能及系统行为建立模型。将用户需求精确化、完全化，最终形成下一步的需求规格说明书.<br>需求提炼 (需求分析) 的核心在于建立分析模型<br>需求提炼 (需求分析) 采用多种形式描述需求，通过建立需求的多种视图，揭<br>示出一些更深的问题。<br>需求提炼 (需求分析) 还包括与客户的交流以澄清某些易混淆的问题，并明确<br>哪些需求更为重要，其目的是确保所有风险承担者尽早地对项目达成共识并对<br>将来的产品有个相同而清晰的认识。</p></blockquote><p>需求分析的过程：需求确认与需求变更</p><p>需求确认的步骤：需求获取→需求提炼→需求描述→需求验证</p><h4 id="需求分析的四个步骤"><a class="markdownIt-Anchor" href="#需求分析的四个步骤">#</a> 需求分析的四个步骤</h4><blockquote><ul><li>需求获取<ul><li><strong>软件需求的来源以及软件工程师收集这些软件需求的方法</strong></li><li>完整定义：指的是软件需求的来源以及软件工程师收集这些软件需求的方法。它也称为需求抓取、需求发现和需求获得</li></ul></li><li>需求提炼<ul><li><strong>产生操作规格参数表，指明与其他系统元件的软件接口，确定软件必须遵循的约束</strong></li><li>完整定义：对应用问题及环境的理解和分析，为问题涉及的信息、功能及系统行为建立模型。将用户需求精确化、完全化，最终形成需求规格说明书。</li></ul></li><li>需求描述<ul><li><strong>撰写 *<em> 需求规格说明书 *</em></strong></li><li>完整定义：软件需求规格说明书 (SRS)---- 是对待开发系统的行为的完整描述，包含了描述用户与软件交互的用例的集合。用例通常描述功能性需求，除了用例之外，SRS 还包含非功能性需求。</li></ul></li><li>需求验证<ul><li><strong>检查需求的 *<em> 正确性、完整性、非二义性 *</em>、内部和外部的 *<em> 连贯性 *</em></strong></li><li>完整定义：需求验证即检查需求的正确性、完整性、非二义性、内部和外部的连贯性。这不可避免地需要用户的参与，用户是问题的所有者，只有他们才能决定需求规格说明书是否恰当描述了他们的问题</li></ul></li></ul></blockquote><h3 id="需求分析三类建模功能模型-数据模型-行为模型"><a class="markdownIt-Anchor" href="#需求分析三类建模功能模型-数据模型-行为模型">#</a> 需求分析三类建模：功能模型、数据模型、行为模型。</h3><h3 id="面向对象的需求分析过程中三类模型各包含哪些内容"><a class="markdownIt-Anchor" href="#面向对象的需求分析过程中三类模型各包含哪些内容">#</a> 面向对象的需求分析过程中，三类模型各包含哪些内容？</h3><ol><li>数据模型：描述系统中数据的结构和关系，一般包括实体、属性和关系三个要素。数据模型是用来帮助开发人员在设计系统时明确数据的概念和关系，进而实现数据的存储、查询、分析和管理。</li><li>功能模型：描述系统的功能和用例，一般包括系统的输入、输出和处理过程。功能模型主要用于帮助开发人员在设计系统时明确系统的功能需求，进而实现系统的设计、开发、测试和维护。</li><li>行为模型：描述系统中各个组成部分的交互和行为，一般包括系统的活动图、状态图和序列图等。行为模型主要用于帮助开发人员在设计系统时明确各个组成部分之间的交互关系和行为规则，进而实现系统的设计、开发、测试和维护。</li></ol><h3 id="uml图类型有哪些"><a class="markdownIt-Anchor" href="#uml图类型有哪些">#</a> UML 图类型有哪些？</h3><p>用例图、类图、活动图</p><h3 id="掌握用例图和活动图作法-泳道划分活动图-分支及汇合-分叉及合并"><a class="markdownIt-Anchor" href="#掌握用例图和活动图作法-泳道划分活动图-分支及汇合-分叉及合并">#</a> 掌握用例图和活动图作法。泳道划分活动图、分支及汇合、分叉及合并</h3><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240101182330195.png" alt="image-20240101182330195"></p><h1 id="4-系统设计"><a class="markdownIt-Anchor" href="#4-系统设计">#</a> 4 系统设计</h1><p>定义<br>在 [IEEE610.12-90] 中，软件设计定义为软件系统或组件的架构、构件、接口和其他特性的定义过程及该过程的结果。</p><p>系统设计分为概要设计和详细设计</p><p>与设计相关的 8 个概念：抽象、信息隐藏、体系结构、功能独立、设计模式、精化、模块化、重构</p><p>抽象、</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240101182546225.png" alt="image-20240101182546225"> 体系结构、</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240101182624813.png" alt="image-20240101182624813"> 设计模式、</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240101182646408.png" alt="image-20240101182646408"></p><p>模块化、</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240101182657645.png" alt="image-20240101182657645"></p><p>信息隐藏、</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240101182708595.png" alt="image-20240101182708595"></p><p>功能独立、</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240101182811842.png" alt="image-20240101182811842"><br>细化、</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240101182819765.png" alt="image-20240101182819765"> 重构。</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/image-20240101182828904.png" alt="image-20240101182828904"></p><p>系统设计从体系结构、数据、接口和组件四方面进行设计。<br>面向对象的系统设计，各自包含哪些设计内容？<br>掌握类图和顺序图作法</p><h1 id="5-质量保证"><a class="markdownIt-Anchor" href="#5-质量保证">#</a> 5 质量保证</h1><h3 id="软件质量的概念和关键点"><a class="markdownIt-Anchor" href="#软件质量的概念和关键点">#</a> 软件质量的概念和关键点。</h3><p>软件质量：明确表示是否符合功能和性能要求，明确地记载开发标准和所有专业开发软件的期望的隐性特点</p><p>关键点：</p><ul><li>符合明确规定的功能和性能要求</li><li>符合明确的开发标准</li><li>符合所有软件开发专业的共性、隐性标准，如易用性、可维护性等测试策略</li></ul><h3 id="v模型概念测试与开发的各阶段对应关系"><a class="markdownIt-Anchor" href="#v模型概念测试与开发的各阶段对应关系">#</a> V 模型概念，测试与开发的各阶段对应关系。</h3><h3 id="什么是v模型"><a class="markdownIt-Anchor" href="#什么是v模型">#</a> 什么是 V 模型</h3><p>RAD（Rapid Application Development，快速应用开发）模型是软件开发过程中的一个重要<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQTglQTElRTUlOUUlOEIvMTc0MTE4Ng==">模型</span>，通过开发和测试同时进行的方式来缩短开发周期，提高开发效率。其形状像一个字母 V，故称为 V 模型。又称软件测试的 V 模型。</p><p>V 模型是一个著名的、以测试为驱动的开发模型，该模型强调开发过程中测试贯穿始终，是瀑布模型的一个变体。V 模型描述了质量保证活动和沟通、建模相关活动以及早期构键相关的活动之间的关系。随着软件团队工作沿着 V 模型左侧步骤向下推进，基本问题需求逐步细化，形成问题及解决方案的技术描述。一旦编码结束，团队沿着 V 模型右侧的步骤向上推进工作，其实际上是执行了一系列测试（质量保证活动），这些测试验证了团队沿着 V 模型左侧步骤向下推进过程中所生成的每个模型。V 模型提供了一种将验证确认活动应用于早期软件工程工作中的方法。</p><h3 id="v模型主要阶段"><a class="markdownIt-Anchor" href="#v模型主要阶段">#</a> V 模型主要阶段</h3><p>V 模型大体可以划分为以下几个不同的阶段步骤：<strong>需求分析、概要设计、详细设计、软件编码、单元测试、集成测试、系统测试、验收测试。</strong></p><ul><li>需求分析<br>即首先要明确客户需要的是什么，需要软件作成什么样子，需要有那几项功能，这一点上比较<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODUlQjMlRTklOTQlQUUvMzMxODM=">关键</span>的是分析师和客户沟通时的理解能力与交互性。要求分析师能准确的把客户所需要达到的功能，实现方式，等表述出来，给出分析结果，写出需求规格说明书。</li><li>概要设计<br>主要是架构的实现，指搭建架构、表述各模块功能、模块接口连接和数据传递的实现等项事务。</li><li>详细设计<br>对概要设计中表述的各模块进行深入分析，对各模块组合进行分析等，这一阶段要求达到伪代码级别，已经把程序的具体实现的功能，现象等描述出来。其中需要包含数据库设计说明。</li><li>软件编码<br>按照详细设计好的模块功能表，编程人员编写出实际的代码。</li><li>单元测试<br>按照设定好的最小测试单元进行按单元测试，主要是测试程序代码，为的是确保各单元模块被正确的编译，单元的具体划分按不同的单位与不同的软件有不同，比如有具体到模块的测试，也有具体到类，函数的测试等。<br>集成测试<br>经过了单元测试后，将各单元组合成完整的体系，主要测试各模块间组合后的功能实现情况，以及模块接口连接的成功与否，数据传递的正确性等，其主要目的是检查软件单位之间的接口是否正确。根据集成测试计划，一边将模块或其他软件单位组合成系统，一边运行该系统，以分析所组成的系统是否正确，各组成部分是否合拍。</li><li>系统测试<br>经过了单元测试和集成测试以后，我们要把软件系统搭建起来，按照软件规格说明书中所要求，测试软件其性能功能等是否和用户需求相符合，在系统中运行是否存在漏洞，等。</li><li>验收测试<br>主要就是用户在拿到软件的时候，在使用现场，会根据前边所提到的需求，以及规格说明书来做相应测试，以确定软件达到预期的效果。</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/1251433-20200202163049839-889429779.png" alt="img"></p><h3 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点">#</a> 优缺点</h3><p>优点：①包含了底层测试（单元测试）和高层测试（系统测试）（底层测试：检验源代码质量的测试，如：单元测试；高层测试：检验整个系统的需要，如：系统测试）；</p><p>②清楚的标识了开发和测试的各个阶段；</p><p>③自上而下逐步求精，每个阶段分工明确，便于整体项目的把控。</p><p>缺点：①自上而下的顺序导致了，测试工作在编码之后，就导致错误不能及时的进行修改；</p><p>②实际工作中，需求经常变化，导致 v 模型步骤，反复执行，返工量很大，灵活度较低。</p><p>改良：每个步骤都可以进行小的迭代（更新）工作。</p><h3 id="对应关系"><a class="markdownIt-Anchor" href="#对应关系">#</a> <strong>对应关系</strong></h3><p>一般来讲：单元测试所对应的是详细设计环节，也就是说，单元测试的测试用例是和详细设计一起出现的，在研发人员做详细设计的时候，相应的测试人员也就把测试用例写了出来；集成测试对应概要设计，在做模块功能分析及模块接口，数据传输方法的时候，就把集成测试用例根据概要设计中模块功能及接口等实现方法编写出来，以备以后作集成测试的时候可以直接引用；而系统测试，就是根据需求分析而来，在系统分析人员作系统分析，编写需求说明书的时候测试人员就根据客户需求说明书，把最后能实现系统功能的各种测试用例写出来，为做最后系统测试作准备。验收测试与用户需求对应，是非设计流程。</p><h3 id="适用范围"><a class="markdownIt-Anchor" href="#适用范围">#</a> 适用范围</h3><p>V 模式是一种传统软件开发模型，一般适用于一些传统信息系统应用的开发，而一些高性能高风险的系统、互联网软件，或一个系统难以被具体模块化的时候，就比较难做成 V 模式所需的各种构件，需要更强调迭代的开发模型或者敏捷开发模型。</p><h3 id="单元测试的内容-集成测试的分类-系统测试的分类-验收测试的分类"><a class="markdownIt-Anchor" href="#单元测试的内容-集成测试的分类-系统测试的分类-验收测试的分类">#</a> 单元测试的内容、集成测试的分类、系统测试的分类、验收测试的分类。</h3><h3 id="v模型"><a class="markdownIt-Anchor" href="#v模型">#</a> <span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1WJUU2JUE4JUExJUU1JTlFJThCJmFtcDtzcG09MTAwMS4yMTAxLjMwMDEuNzAyMA==">V 模型</span></h3><blockquote><p>V 模型非常明确地标明了测试过程中存在的不同级别，并且清楚地描述了这些测试阶段和开发过程期间各阶段对应关系：</p><ol><li><strong>单元测试</strong>的主要目的是验证软件模块是否按详细设计的规格说明正确运行；</li><li><strong>集成测试</strong>的主要目的是检查多个模块间是否按概要设计说明的方式协同工作；</li><li><strong>系统测试</strong>的主要目的是验证整个系统是否满足需求规格说明；</li><li><strong>验收测试</strong>从用户的角度检查系统是否满足合同中定义的需求，以及确认产品是否能符合业务上的要求</li></ol></blockquote><h3 id="回归测试"><a class="markdownIt-Anchor" href="#回归测试">#</a> <span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTUlOUIlOUUlRTUlQkQlOTIlRTYlQjUlOEIlRTglQUYlOTUmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">回归测试</span></h3><blockquote><p><strong>有选择的</strong>重新测试系统或其组件，以验证对软件的修改没有导致不希望出现的影响，以及系统或组件仍然符合其指定的需求。</p><p>回归测试可以在所有的测试级别执行，并且应用于<strong>功能和非功能测试</strong>中。</p><p>回归测试应该尽量采用<strong>自动化测试</strong></p></blockquote><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试">#</a> <span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTUlOEQlOTUlRTUlODUlODMlRTYlQjUlOEIlRTglQUYlOTUmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">单元测试</span></h3><blockquote><p>单元：</p><ul><li>面向过程的语言：函数 / 过程</li><li>面向对象的语言：成员函数 / 类本身</li></ul><p>主要依据：</p><ul><li>是详细设计，不是针对代码的测试</li><li>因为未测代码可能包含错误和缺陷，如果依照其测试，则可能无法发现一些错误</li></ul><p>主要内容：</p><ul><li>模块接口</li><li>局部数据结构</li><li>边界条件</li><li>独立路径</li><li>出错处理</li></ul></blockquote><hr><h3 id="集成测试"><a class="markdownIt-Anchor" href="#集成测试">#</a> 集成测试</h3><blockquote><h4 id="重要概念"><a class="markdownIt-Anchor" href="#重要概念">#</a> 重要概念</h4><p>桩模块：用以代替被测模块调用的子模块，可以做少量数据操作</p><p>驱动模块：相当于被测模块的主程序，接受测试数据传送给被测模块，最后输出实测结果</p></blockquote><h4 id="自顶向下的集成方法"><a class="markdownIt-Anchor" href="#自顶向下的集成方法">#</a> 自顶向下的集成方法</h4><blockquote><p>将模块按系统程序结构，沿控制层次自顶向下进行集成，从属于主控模块的按深度优先方式或广度优先方式集成到结构中去。</p><p>优点：较早验证了主要的控制和判断点；选用了按深度方向集成的方式，可以首先实现和验证一个完整的软件功能</p><p>缺点：桩的开发量较大</p></blockquote><h4 id="自底向上的集成方法"><a class="markdownIt-Anchor" href="#自底向上的集成方法">#</a> 自底向上的集成方法</h4><blockquote><p>从软件最底层模块开始，按照接口依赖关系逐层向上集成进行测试。</p><p>优点：每个底层模块都得到测试，不需要桩模块。</p><p>缺点：每个模块都需要编写驱动模块；缺陷的隔离和定位不如自顶向下。</p></blockquote><h4 id="smoke方法"><a class="markdownIt-Anchor" href="#smoke方法">#</a> SMOKE 方法</h4><blockquote><p>系统最基本功能的测试，快速验证基本功能，在软件代码正是编译并交付测试以前先尽量消除其表面的错误，减少后期测试成本。</p><p>优点：节省测试时间，防止构造失败</p><p>缺点：覆盖率比较低</p></blockquote><hr><h3 id="系统测试"><a class="markdownIt-Anchor" href="#系统测试">#</a> 系统测试</h3><blockquote><p>主要内容有：功能性测试、性能测试、压力测试、恢复测试、安全测试、其他测试（配置测试、兼容性测试、本地化测试、文档测试、易用性测试）</p></blockquote><hr><h3 id="验收测试"><a class="markdownIt-Anchor" href="#验收测试">#</a> 验收测试</h3><blockquote><p>时间：通过系统有效性测试及软件配置审查以后，开始系统验收测试。</p><p>人员：以用户为主，开发人员和质量保证员也应参加。</p><p>内容：由用户参加设计测试用例，使用生产中的实际数据进行测试。</p></blockquote><p>回归测试的概念、 测试技术常见术语的概念：软件缺陷、验证和确认、测试与质量保证、质量与可靠性、调试与测试、测试用例</p><p>软件测试的定义<br>在某种指定的条件下对系统或组件操作，观察或记录结果，对系统或组件的某些方面进行评估的过程。分析软件各项目以检测现有的结果和应有结果之间的差异，并评估软件各项目的特征的过程。</p><h3 id="软件测试"><a class="markdownIt-Anchor" href="#软件测试">#</a> <span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTglQkQlQUYlRTQlQkIlQjYlRTYlQjUlOEIlRTglQUYlOTUmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">软件测试</span></h3><h4 id="基本原则"><a class="markdownIt-Anchor" href="#基本原则">#</a> 基本原则</h4><blockquote><ul><li>穷尽测试是不可能的：决定哪些更重要</li><li>测试无法显示潜在的软件缺陷：不能保证没有错误</li><li>测试活动应该尽早进行：越早发现修改成本越低</li><li>软件缺陷具有群聚性：一个问题出错导致多个错误现象出现</li><li>注意杀虫剂现象：用异样的测试用例是不可取的（可能是少数能通过的特例）</li><li>应尽量由独立的测试团队进行测试：自己测试自己是不可取的（想不到特殊情况）</li></ul></blockquote><h4 id="目标"><a class="markdownIt-Anchor" href="#目标">#</a> 目标</h4><blockquote><ul><li>确认系统满足其预期的使用和用户的需要</li><li>确认解决了所需解决的问题</li><li>为测试的过程建立责任和可解释性</li><li>便于及早发现软件和系统的异常</li><li>及早提供软件和系统的性能评估</li><li>为管理提供真实信息，以决定在当前状态下发布产品在商业上的风险</li><li>鉴别出程序在功能等方面的异常聚集之处</li></ul></blockquote><h4 id="测试用例"><a class="markdownIt-Anchor" href="#测试用例">#</a> 测试用例</h4><blockquote><p><strong>定义</strong>：是测试输入、执行条件，以及预期结果的集合</p><p><strong>目的</strong>：为特定目的开发，如执行特定的程序路径或验证与指定的需求相符合</p></blockquote><h3 id="软件缺陷"><a class="markdownIt-Anchor" href="#软件缺陷">#</a> 软件缺陷</h3><blockquote><p>满足下面条件之一即发生软件缺陷：</p><ul><li>未完成：软件未实现产品说明书要求的功能。</li><li>有错误：软件出现了产品说明书指明不能出现的错误。</li><li>画蛇添足：软件实现了产品说明书未提到的功能</li><li>隐含需求未实现：软件未实现产品说明书虽未明确提及但应该实现的目标。</li><li>不好用：软件难以理解、不易使用、运行缓慢</li></ul></blockquote><h4 id="调试与测试"><a class="markdownIt-Anchor" href="#调试与测试">#</a> 调试与测试</h4><blockquote><p><strong>相同点</strong>：都包含处理软件缺陷和查看代码的过程</p><p><strong>不同点</strong>：测试的目标时<strong>发现软件缺陷的存在</strong>；调试的目标是<strong>定位与修复缺陷</strong>。</p></blockquote><h4 id="测试与质量保证"><a class="markdownIt-Anchor" href="#测试与质量保证">#</a> 测试与质量保证</h4><blockquote><ul><li>软件测试人员的目标：尽早找出软件缺陷并确保缺陷得以修复</li><li>软件质量保证人员的主要职责：创建和执行改进软件开发过程并防止软件缺陷发生的标准和方法</li></ul></blockquote><h4 id="软件测试的评估准则"><a class="markdownIt-Anchor" href="#软件测试的评估准则">#</a> 软件测试的评估准则</h4><blockquote><p>覆盖率：测试集合 T / 测试需求集合 TB</p><p>故障插入：测试前有意地插入一些故障到程序中，发现率 = 发现的插入错误数 / 总错误数</p><p>变异分值：程序进行多次变异，用同样的测试用例进行测试，评估这些测试用例探测程序变异间差异的能力，如错误的标识符或运算符等。</p></blockquote><h3 id="白盒测试-黑盒测试-静态分析各有哪些方法"><a class="markdownIt-Anchor" href="#白盒测试-黑盒测试-静态分析各有哪些方法">#</a> 白盒测试、黑盒测试、静态分析各有哪些方法？</h3><h3 id="黑盒测试"><a class="markdownIt-Anchor" href="#黑盒测试">#</a> <span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTklQkIlOTElRTclOUIlOTIlRTYlQjUlOEIlRTglQUYlOTUmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">黑盒测试</span></h3><blockquote><h4 id="定义"><a class="markdownIt-Anchor" href="#定义">#</a> 定义</h4><p>黑盒测试指忽略系统或组件的内部机制，仅关注于那些特定输入响应及相应执行条件的输出测试，也称功能性测试。</p><p>把测试对象看做一个黑盒子，测试人员完全不考虑程序内部逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。</p><p><strong>分类</strong></p><h4 id="等价类划分"><a class="markdownIt-Anchor" href="#等价类划分">#</a> <span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTclQUQlODklRTQlQkIlQjclRTclQjElQkIlRTUlODglOTIlRTUlODglODYmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">等价类划分</span></h4><p>含义：等价类划分方法把所有可能的输入数据，即程序的输入域划分成若干部分，然后从每一部分中选取少许有代表性的数据作为测试用例</p><p>步骤：对输入域进行建模、对参数进行等价类划分、对参数进行恰当的组合。</p><h4 id="边界值分析"><a class="markdownIt-Anchor" href="#边界值分析">#</a> 边界值分析</h4><p>边界：对输入等价类和输出等价类而言，稍高于其边界值及稍低于其边界值的一些特定情况。</p><p>边界选取：应当选取正好等于、刚刚大于、或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值。</p><h4 id="状态测试"><a class="markdownIt-Anchor" href="#状态测试">#</a> 状态测试</h4><p>必要性：黑盒测试阶段，程序内部的逻辑结构无从得知，因此只能通过状态测试间接验证。</p><p>含义：一种基于模型的测试，是指用状态图来描述时间序列 / 用例场景，由此产生测试用例</p><p>步骤：建立状态转换图、设计测试用例。</p></blockquote><hr><h3 id="白盒测试"><a class="markdownIt-Anchor" href="#白盒测试">#</a> 白盒测试</h3><blockquote><h4 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2">#</a> 定义</h4><p>白盒测试指考虑系统或组件内部机制的测试（如分支测试、路径测试、语句测试等)，也称结构性测试。</p><p>把测试对象看作一个透明的盒子，它允许测试人员利用程序的内部逻辑结构及有关信息设计或选择测试用例，对程序的所有逻辑路径进行测试，通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。</p><h4 id="逻辑覆盖测试"><a class="markdownIt-Anchor" href="#逻辑覆盖测试">#</a> 逻辑覆盖测试</h4><p>含义：以程序内部的逻辑结构为基础的设计测试用例的技术，属于白盒测试。</p><p>分类：</p><p>语句覆盖：每条可执行语句至少执行一次</p><p>条件覆盖：每个条件的可能取值至少执行一次</p><p>分支覆盖：每个判断的取真分支和取假分支都经历一次</p><p>条件组合覆盖：每个判断所有可能取值条件的组合都经历一次</p><h4 id="控制流图覆盖测试"><a class="markdownIt-Anchor" href="#控制流图覆盖测试">#</a> 控制流图覆盖测试</h4><p>含义：把代码转换为控制流图，基于其进行测试，属于白盒测试。</p><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/2cc5d50ebbce411a8c846a391bff3089.png" alt="img"></p><p>注意：</p><ul><li>在选择或多分支结构中，分支的汇聚处应有一个汇聚结点</li><li>边和结点圈定的区域叫做区域，当对区域计数时，图形外的区域也应记为一个区域</li><li>如果判断中的条件表达式是由一个或多个逻辑运算符 (OR，AND,NAND，NOR) 连接的复合条件表达式，则需要改为一系列只有单个条件的嵌套的判断</li></ul><p>节点覆盖：等价于语句覆盖</p><p>边覆盖：包含节点覆盖且也可以实现分支覆盖</p><p>路径覆盖：覆盖程序中所有可能的路径 (基本路径测试)</p><h4 id="基本路径测试"><a class="markdownIt-Anchor" href="#基本路径测试">#</a> 基本路径测试</h4><ul><li>计算程序环路复杂性：<ul><li>①V (G)=e-n+2，e：图中边的数目；n：节点数目；</li><li>②区域数目</li></ul></li><li>确定线性独立性的基本集合：<ul><li>从入口走到出口作为基线，回溯基线路径，当出度大于等于 2 时选择不同的边，重复直到路径数目等于 V (G)</li></ul></li><li>为每条基本路径导出测试用例：<ul><li>确保基本路径集中的每一条路径的执行，用逻辑覆盖方法保证某条路径可被测试到，最后执行测试用例与预期结果比较</li></ul></li></ul></blockquote><hr><h3 id="灰盒测试"><a class="markdownIt-Anchor" href="#灰盒测试">#</a> 灰盒测试</h3><blockquote><p>黑盒和白盒测试混合方法。</p><p>介于白盒测试和黑盒测试之间的一种测试，多用于集成测试阶段，不仅关注输入输出的正确性，同时也关注程序内部的情况。</p></blockquote><hr><h3 id="静态测试"><a class="markdownIt-Anchor" href="#静态测试">#</a> 静态测试</h3><blockquote><h4 id="含义"><a class="markdownIt-Anchor" href="#含义">#</a> 含义</h4><p>不实际运行程序，通过检查和阅读等手段发现错误、评估代码质量的软件测试技术。</p><h4 id="范围"><a class="markdownIt-Anchor" href="#范围">#</a> 范围</h4><p>代码检查、静态结构分析、代码质量度量</p><h4 id="目的"><a class="markdownIt-Anchor" href="#目的">#</a> 目的</h4><p>提高代码可靠性、尽早发现缺陷、审核定位易出错模块</p><h4 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想">#</a> 基本思想</h4><p>评审</p><h4 id="三种评审类型"><a class="markdownIt-Anchor" href="#三种评审类型">#</a> 三种评审类型</h4><p>同事审查：非正式评审，初次审查</p><p>走查：开发组内部进行，开发者讲解、回答问题、记录</p><p>审查：会议形式，制定目标流程规则结果报告等</p></blockquote><h3 id="掌握等价类划分测试方法-有效等价类和无效等价类划分-对应测试用例的设计"><a class="markdownIt-Anchor" href="#掌握等价类划分测试方法-有效等价类和无效等价类划分-对应测试用例的设计">#</a> 掌握等价类划分测试方法。 （有效等价类和无效等价类划分、对应测试用例的设计）</h3><p>项目管理四要素：人员、产品、项目、过程（概念）</p><h3 id="软件度量有哪些方法"><a class="markdownIt-Anchor" href="#软件度量有哪些方法">#</a> 软件度量有哪些方法</h3><h3 id="测量软件生产率的两种方法"><a class="markdownIt-Anchor" href="#测量软件生产率的两种方法">#</a> 测量软件生产率的两种方法</h3><blockquote><p>软件生产率测量的两种方式：</p><p>直接测量：基于 LOC（一定时间产生的代码行数）</p><p>间接测量：基于功能点（给定时间内产出的功能点目标点）</p></blockquote><h4 id="基于loc测量"><a class="markdownIt-Anchor" href="#基于loc测量">#</a> 基于 LOC 测量</h4><blockquote><h4 id="例题"><a class="markdownIt-Anchor" href="#例题">#</a> 例题：</h4><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/39ed38acc5474d9aa91e6c293e32cbd3.png" alt="img"></p><h4 id="优点"><a class="markdownIt-Anchor" href="#优点">#</a> 优点</h4><ul><li>LOC、KLOC 和相关度量容易计算</li><li>许多现有的软件估算模型都使用 LOC 和 KLOC 作为一项重要输入</li><li>有大量的关于 LOC 的文献和数据</li></ul><h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点">#</a> 缺点</h4><ul><li>LOC 依赖于使用的语言，这对短小精悍的程序不利</li><li>不太适用于非过程化语言</li><li>LOC 是由在设计完成时候才能计算，估算需要一定程度的细节，而这些细节可能很难获得，例如，项目计划人员难于在分析和设计完成之前估算 LOC</li></ul></blockquote><h4 id="基于功能点测量"><a class="markdownIt-Anchor" href="#基于功能点测量">#</a> 基于功能点测量</h4><blockquote><ul><li>复杂性调整值：14 个复杂性因素之和，sum (Fi)</li><li>功能点总数：sum (数量 * 功能点个数)</li><li>功能点计算公式 (FP)：FP=(total_counts)<em>(0.65+0.01</em>sum(Fi))</li><li>每 FP 的错误数 / 缺陷数 / 文档页数：总的 *** 数 / FP 数</li><li>每人月的 FP 数：FP 数 / 总的人月数</li></ul><h4 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2">#</a> 例题：</h4><p><img data-src="https://cdn.jsdelivr.net/gh/TV233/blogpic@main//img/e010c28975b5464083c6aab27ac17c2e.png" alt="img"></p><p>还可根据经验度量、通过任务分解度量工作量、根据目前可用资源估算项目工作量…</p></blockquote><p><strong>成本估算的方法之一：COCOMO 模型，了解即可。</strong></p><div class="tags"><a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="ic i-tag"></i> 学习</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-08-03 20:19:39" itemprop="dateModified" datetime="2024-08-03T20:19:39+08:00">2024-08-03</time> </span><span id="2024/06/20/软件工程复习1/" class="item leancloud_visitors" data-flag-title="软件工程复习" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Tviak <i class="ic i-at"><em>@</em></i>Tviak的普通观测站</li><li class="link"><strong>本文链接：</strong> <a href="https://blog.vktia.me/2024/06/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A01/" title="软件工程复习">https://blog.vktia.me/2024/06/20/软件工程复习1/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;TV233&#x2F;blogpic@master&#x2F;img&#x2F;77414471_p10.jpg" title="数据库复习"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>数据库复习</h3></a></div><div class="item right"><a href="/2024/06/28/GitHub/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;TV233&#x2F;blogpic@master&#x2F;img&#x2F;77414471_p10.jpg" title="GitHub 学生包 Proof Type 选项消失解法"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>GitHub 学生包 Proof Type 选项消失解法</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1 软件工程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.0.1.</span> <span class="toc-text">软件的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.0.2.</span> <span class="toc-text">软件的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.0.3.</span> <span class="toc-text">软件危机的概念和产生的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89-%E4%B8%89%E8%A6%81%E7%B4%A0-%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.0.4.</span> <span class="toc-text">软件工程的定义、三要素、应用软件工程的原因</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">2 软件过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A6%82%E5%BF%B5"><span class="toc-number">2.0.1.</span> <span class="toc-text">软件生命周期概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">2.0.2.</span> <span class="toc-text">软件过程概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.3.</span> <span class="toc-text">软件过程模型的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8E%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">2.0.4.</span> <span class="toc-text">软件工程的中心与三要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.5.</span> <span class="toc-text">软件生存期模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.5.1.</span> <span class="toc-text">瀑布模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.5.2.</span> <span class="toc-text">快速原型模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.5.3.</span> <span class="toc-text">增量模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.5.4.</span> <span class="toc-text">螺旋模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">3 需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">需求分析的四个步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%89%E7%B1%BB%E5%BB%BA%E6%A8%A1%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9E%8B-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.0.1.</span> <span class="toc-text">需求分析三类建模：功能模型、数据模型、行为模型。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%89%E7%B1%BB%E6%A8%A1%E5%9E%8B%E5%90%84%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9"><span class="toc-number">3.0.2.</span> <span class="toc-text">面向对象的需求分析过程中，三类模型各包含哪些内容？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uml%E5%9B%BE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.0.3.</span> <span class="toc-text">UML 图类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%8C%E6%8F%A1%E7%94%A8%E4%BE%8B%E5%9B%BE%E5%92%8C%E6%B4%BB%E5%8A%A8%E5%9B%BE%E4%BD%9C%E6%B3%95-%E6%B3%B3%E9%81%93%E5%88%92%E5%88%86%E6%B4%BB%E5%8A%A8%E5%9B%BE-%E5%88%86%E6%94%AF%E5%8F%8A%E6%B1%87%E5%90%88-%E5%88%86%E5%8F%89%E5%8F%8A%E5%90%88%E5%B9%B6"><span class="toc-number">3.0.4.</span> <span class="toc-text">掌握用例图和活动图作法。泳道划分活动图、分支及汇合、分叉及合并</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">4 系统设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81"><span class="toc-number">5.</span> <span class="toc-text">5 质量保证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">5.0.1.</span> <span class="toc-text">软件质量的概念和关键点。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v%E6%A8%A1%E5%9E%8B%E6%A6%82%E5%BF%B5%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%BC%80%E5%8F%91%E7%9A%84%E5%90%84%E9%98%B6%E6%AE%B5%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">5.0.2.</span> <span class="toc-text">V 模型概念，测试与开发的各阶段对应关系。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFv%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.0.3.</span> <span class="toc-text">什么是 V 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v%E6%A8%A1%E5%9E%8B%E4%B8%BB%E8%A6%81%E9%98%B6%E6%AE%B5"><span class="toc-number">5.0.4.</span> <span class="toc-text">V 模型主要阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.0.5.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">5.0.6.</span> <span class="toc-text">对应关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">5.0.7.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%86%85%E5%AE%B9-%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB-%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB-%E9%AA%8C%E6%94%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.0.8.</span> <span class="toc-text">单元测试的内容、集成测试的分类、系统测试的分类、验收测试的分类。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.0.9.</span> <span class="toc-text">V 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.10.</span> <span class="toc-text">回归测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.11.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.12.</span> <span class="toc-text">集成测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-number">5.0.12.1.</span> <span class="toc-text">重要概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E9%9B%86%E6%88%90%E6%96%B9%E6%B3%95"><span class="toc-number">5.0.12.2.</span> <span class="toc-text">自顶向下的集成方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E9%9B%86%E6%88%90%E6%96%B9%E6%B3%95"><span class="toc-number">5.0.12.3.</span> <span class="toc-text">自底向上的集成方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#smoke%E6%96%B9%E6%B3%95"><span class="toc-number">5.0.12.4.</span> <span class="toc-text">SMOKE 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.13.</span> <span class="toc-text">系统测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E6%94%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.14.</span> <span class="toc-text">验收测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.15.</span> <span class="toc-text">软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">5.0.15.1.</span> <span class="toc-text">基本原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-number">5.0.15.2.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">5.0.15.3.</span> <span class="toc-text">测试用例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7"><span class="toc-number">5.0.16.</span> <span class="toc-text">软件缺陷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.16.1.</span> <span class="toc-text">调试与测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81"><span class="toc-number">5.0.16.2.</span> <span class="toc-text">测试与质量保证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%AF%84%E4%BC%B0%E5%87%86%E5%88%99"><span class="toc-number">5.0.16.3.</span> <span class="toc-text">软件测试的评估准则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%90%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">5.0.17.</span> <span class="toc-text">白盒测试、黑盒测试、静态分析各有哪些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.18.</span> <span class="toc-text">黑盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">5.0.18.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86"><span class="toc-number">5.0.18.2.</span> <span class="toc-text">等价类划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90"><span class="toc-number">5.0.18.3.</span> <span class="toc-text">边界值分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.18.4.</span> <span class="toc-text">状态测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.19.</span> <span class="toc-text">白盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">5.0.19.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.19.2.</span> <span class="toc-text">逻辑覆盖测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.19.3.</span> <span class="toc-text">控制流图覆盖测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.19.4.</span> <span class="toc-text">基本路径测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.20.</span> <span class="toc-text">灰盒测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%B5%8B%E8%AF%95"><span class="toc-number">5.0.21.</span> <span class="toc-text">静态测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E4%B9%89"><span class="toc-number">5.0.21.1.</span> <span class="toc-text">含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4"><span class="toc-number">5.0.21.2.</span> <span class="toc-text">范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-number">5.0.21.3.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">5.0.21.4.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E8%AF%84%E5%AE%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.0.21.5.</span> <span class="toc-text">三种评审类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%8C%E6%8F%A1%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95-%E6%9C%89%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%92%8C%E6%97%A0%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86-%E5%AF%B9%E5%BA%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.0.22.</span> <span class="toc-text">掌握等价类划分测试方法。 （有效等价类和无效等价类划分、对应测试用例的设计）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BA%A6%E9%87%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">5.0.23.</span> <span class="toc-text">软件度量有哪些方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E9%87%8F%E8%BD%AF%E4%BB%B6%E7%94%9F%E4%BA%A7%E7%8E%87%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">5.0.24.</span> <span class="toc-text">测量软件生产率的两种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eloc%E6%B5%8B%E9%87%8F"><span class="toc-number">5.0.24.1.</span> <span class="toc-text">基于 LOC 测量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">5.0.24.2.</span> <span class="toc-text">例题：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">5.0.24.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">5.0.24.4.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8A%9F%E8%83%BD%E7%82%B9%E6%B5%8B%E9%87%8F"><span class="toc-number">5.0.24.5.</span> <span class="toc-text">基于功能点测量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">5.0.24.6.</span> <span class="toc-text">例题：</span></a></li></ol></li></ol></li></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Tviak" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Tviak</p><div class="description" itemprop="description">观测世界和自己的一般通过观测者</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">56</span> <span class="name">文章</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RWMjMz" title="https:&#x2F;&#x2F;github.com&#x2F;TV233"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTI4MDI1MTMzMQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;280251331"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnZrQHZrdGlhLm1l" title="mailto:vk@vktia.me"><i class="ic i-envelope"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNzk4ODU0MQ==" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;7988541"><i class="ic i-youtube"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>主页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/06/28/GitHub/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2020/04/25/%E6%B5%8B%E8%AF%95/" title="233">233</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/20/qt/" title="C++ &amp; Qt 复习笔记">C++ & Qt 复习笔记</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/11/07/20231107/" title="随便写写">随便写写</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/05/21/%E5%9B%9E%E6%9C%9B/" title="回望">回望</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2020/03/18/%E5%A5%BD%E5%83%8F%E5%BC%84%E5%A5%BD%E4%BA%86/" title="233">233</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/29/%E6%B7%B1%E5%85%A5CSS/" title="深入CSS 青训营前端基础班 Day3">深入CSS 青训营前端基础班 Day3</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/28/GitHub/" title="GitHub 学生包 Proof Type 选项消失解法">GitHub 学生包 Proof Type 选项消失解法</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/03/03/%E7%88%AC%E8%99%AB%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%9E%E6%88%98/" title="爬虫，但是实战">爬虫，但是实战</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/12/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="HTML学习笔记">HTML学习笔记</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/08/06/%E7%88%B1%E6%80%9D%E8%87%AA%E7%AD%BE%E9%97%AE%E9%A2%98/" title="爱思自签问题">爱思自签问题</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Tviak @ Tviak's Observatory</span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">215k 字</span> <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:53</span></div><p id="hitokoto"><a href="#" id="hitokoto_text">:D 获取中...</a></p><script>fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      const hitokoto = document.querySelector('#hitokoto_text')
      hitokoto.href = `https://hitokoto.cn/?uuid=${data.uuid}`
      hitokoto.innerText = data.hitokoto
    })
    .catch(console.error)</script><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span><br><a href="https://icp.gov.moe/?keyword=20237705" target="_blank">萌ICP备20237705号</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/06/20/软件工程复习1/",favicon:{show:"（●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://polyfill.alicdn.com/polyfill.min.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>